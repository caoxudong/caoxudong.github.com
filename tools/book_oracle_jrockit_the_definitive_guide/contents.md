#目录

* [1 起步][1]
    * [1.1 获得JRockit JVM][2]
    * [1.2 将应用程序迁移到JRockit][3]
        * [1.2.1 命令行选项][4]
            * [1.2.1.1 系统属性][5]
            * [1.2.1.2 标准命令行选项][6]
            * [1.2.1.3 非标准命令行选项][7]
        * [1.2.2 行为差异][8]
    * [1.3 JRockit版本号的命名规则][9]
    * [1.4 获取帮助][10]
    * [1.5 小结][11]
* [2 自适应代码生成][12]
    * [2.1 平台无关性][13]
    * [2.2 Java虚拟机][14]
        * [2.2.1 基于栈的虚拟机][15]
        * [2.2.2 字节码格式][16]
            * [2.2.2.1 操作与操作数][17]
            * [2.2.2.2 常量池][18]
    * [2.3 代码生成策略][19]
        * [2.3.1 纯解释执行][20]
        * [2.3.2 静态编译][21]
        * [2.3.3 完全JIT编译][22]
        * [2.3.4 混合模式][23]
    * [2.4 自适应代码生成][24]
        * [2.4.1 判断热方法][25]
            * [2.4.1.1 调用计数器][26]
            * [2.4.1.2 基于软件的线程采样][27]
            * [2.4.1.3 硬件采样][28]
        * [2.4.2 优化动态程序][29]
    * [2.5 深入JIT编译器][30]
        * [2.5.1 处理字节码][31]
            * [2.5.1.1 字节码混淆][32]
        * [2.5.2 字节码“优化器”][33]
            * [2.5.2.1 抽象语法树][34]
        * [2.5.3 优化字节码][35]
    * [2.6 代码流水线][36]
        * [2.6.1 为什么JRockit没有字节码解释器][37]
        * [2.6.2 启动][38]
        * [2.6.3 运行时代码生成][39]
            * [2.6.3.1 Trampolines][40]
            * [2.6.3.2 代码生成请求][41]
            * [2.6.3.3 代码优化请求][42]
            * [2.6.3.4 栈上替换][43]
            * [2.6.3.5 簿记][44]
        * [2.6.4 代码生成概述][45]
            * [2.6.4.1 代码的中间表示][46]
            * [2.6.4.2 JIT编译][47]
            * [2.6.4.3 代码优化][48]
    * [2.7 控制代码生成][49]
        * [2.7.1 命令行选项与指导文件][50]
            * [2.7.1.1 命令行选项][51]
            * [2.7.1.2 指导文件][52]
    * [2.8 小结][53]
* [3 自适应内存管理][54]
    * [3.1 自动内存管理相关概念][55]
        * [3.1.1 自适应内存管理][56]
        * [3.1.2 自动内存管理的优点][57]
        * [3.1.3 自动内存管理的缺点][58]
    * [3.2 堆管理基础][59]
        * [3.2.1 对象的分配于释放][60]
        * [3.2.2 碎片与整理][61]
    * [3.3 垃圾回收算法][62]
        * [3.3.1 引用计数][63]
        * [3.3.2 引用跟踪][64]
            * [3.3.2.1 标记-清理][65]
            * [3.3.2.2 暂停-拷贝][66]
        * [3.3.3 STW(stop-the-world)][67]
            * [3.3.3.1 保守式 vs. 准确式][68]
            * [3.3.3.2 livemap][69]
        * [3.3.4 分代垃圾回收][70]
            * [3.3.4.1 多个新生代的内存排布][71]
            * [3.3.4.2 写屏障][72]
        * [3.3.5 吞吐量 vs. 延迟][73]
            * [3.3.5.1 优化吞吐量][74]
            * [3.3.5.2 优化延迟][75]
        * [3.3.6 JRockit中的垃圾回收][76]
            * [3.3.6.1 老年代垃圾回收][77]
            * [3.3.6.2 新生代垃圾回收][78]
            * [3.3.6.3 永生代垃圾回收][79]
        * [3.3.6.4 内存整理][80]
    * [3.4 性能与伸缩性][81]
        * [3.4.1 线程局部分配][82]
        * [3.4.2 更大的堆内存][83]
            * [3.4.2.1 32位架构下的4GB内存限制][84]
            * [3.4.2.2 64位架构][85]
        * [3.4.3 缓存友好性][86]
            * [3.4.3.1 预抓取][87]
            * [3.4.3.2 数据存放][88]
        * [3.4.4 NUMA][89]
        * [3.4.5 大内存页（Large pages）][90]
        * [3.4.6 自适应（Adaptability）][91]
    * [3.5 近实时垃圾回收][92]
        * [3.5.1 软实时与硬实时][93]
        * [3.5.2 JRockit Real Time][94]
            * [3.5.2.1 软实时有效么？][95]
            * [3.5.2.2 工作原理][96]
    * [3.6 内存操作相关的API][97]
        * [3.6.1 析构函数][98]
        * [3.6.2 Java中的引用][99]
            * [3.6.2.1 弱引用][100]
            * [3.6.2.2 软引用][101]
            * [3.6.2.3 虚引用][102]
        * [3.6.3 JVM的行为差异][103]
    * [3.7 陷阱与伪优化][104]
        * [3.7.1 Java不是C++][105]
    * [3.8 JRockit中的内存管理][106]
        * [3.8.1 基本参数][107]
           * [3.8.1.1 打印垃圾回收日志][108]
           * [3.8.1.2 设置堆的初始值和最大值][109]
           * [3.8.1.3 设置垃圾回收器的执行目标][110]
           * [3.8.1.4 指定垃圾回收策略][111]
        * [3.8.2 压缩引用][112]
        * [3.8.3 高级选项][113]
    * [3.9 小结][114]
* [4 线程与同步][115]
    * [4.1 基本概念][116]
        * [4.1.1 难以调试][117]
        * [4.1.2 难以优化][118]
            * [4.1.2.1 延迟性分析][119]
    * [4.2 Java API][120]
        * [4.2.1 synchromized关键字][121]
        * [4.2.2 java.lang.Thread类][122]
        * [4.2.3 java.util.concurrent包][123]
        * [4.2.4 信号量][124]
        * [4.2.5 volatile关键字][125]
    * [4.3 Java中线程与同步机制的实现][126]
        * [4.3.1 Java内存模型][127]
            * [4.3.1.1 早期内存模型中的问题][128]
            * [4.3.1.2 JSR-133][129]
        * [4.3.2 同步的实现][130]
            * [4.3.2.1 原生机制][131]
            * [4.3.2.2 锁(Lock)][132]
        * [4.3.3 同步在字节码中的实现][133]
            * [4.3.3.1 匹配的锁操作][134]
        * [4.3.4 线程的实现][135]
            * [4.3.4.1 绿色线程（green thread）][136]
            * [4.3.4.2 操作系统线程][137]
    * [4.4 对于线程与同步的优化][138]
        * [4.4.1 锁膨胀与锁收缩][139]
        * [4.4.2 递归锁][140]
        * [4.4.3 锁融合][141]
        * [4.4.4 延迟解锁][142]
            * [4.4.4.1 实现][143]
            * [4.4.4.2 禁用对象][144]
            * [4.4.4.3 禁用类][145]
            * [4.4.4.4 结论][146]
    * [4.5 陷阱与伪优化][147]
        * [4.5.1 问题方法：`Thread.stop` `Thread.resume` `Thread.suspend`][148]
        * [4.5.2 双检查锁][149]
    *[4.6 相关命令行参数][150]
        * [4.6.1 检查锁与延迟解锁][151]
            * [4.6.1.1 使用`-Xverbose:locks`参数分析锁的行为][152]
            * [4.6.1.2 使用参数`-XX:UseLazyUnlocking`][153]
        * [4.6.2 输出调用栈信息][154]
        * [4.6.3 锁分析][155]
            * [4.6.3.1 使用参数`-XX:UseLockProfiling`进行所分析][156]
        * [4.6.4 设置线程栈的大小][157]
        * [4.6.5 使用命令行参数控制锁的行为][158]
    * [4.7 小结][159]
* [5 基准测试与性能调优][160]
    * [5.1 为何要进行基准测试][161]
        * [5.1.1 制定性能目标][162]
        * [5.1.2 对性能进行回归测试][163]
        * [5.1.3 确定优化方向][164]
        * [5.1.4 商业应用][165]
    * [5.2 如何构建基准测试][166]
        * [5.2.1 "置身事外（outside the system）"][167]
        * [5.2.2 测量时间][168]
        * [5.2.3 微基准测试（micro benchmark）][169]
            * [5.2.3.1 基准测试与栈上替换][170]
            * [5.2.3.2 基准测试与启动时间][171]
        * [5.2.4 测试前要热身][172]
    * [5.3 确定测试目标][173]
        * [5.3.1 吞吐量][174]
        * [5.3.2 兼顾吞吐量、响应时间和延迟][175]
        * [5.3.3 伸缩性][176]
        * [5.3.4 能源消耗][177]
        * [5.3.5 其他方面][178]
    * [5.4 工业级基准测试][179]
        * [5.4.1 SPEC基准测试套件][180]
            * [5.4.1.1 SPECjvm基准测试套件][181]
            * [5.4.1.2 SPECjAppServer套件/SPECjEnterprise2010套件][182]
            * [5.4.1.3 SPECjbb套件][183]
        * [5.4.2 SipStone基准测试][184]
        * [5.4.3 DaCapo基准测试][185]
        * [5.4.4 真实场景下的应用程序][186]
    * [5.5 基准测试的潜在风险][187]
    * [5.6 性能调优][188]
        * [5.6.1 非规范化行为（Out of the box behavior）][189]
        * [5.6.2 调优目标][190]
            * [5.6.2.1 内存管理调优][191]
            * [5.6.2.2 代码生成调优][192]
            * [5.6.2.3 锁与线程调优][193]
            * [5.6.2.4 其他相关调优][194]
    * [5.7 常见性能瓶颈与规避方法][195]
        * [5.7.1 命令行参数`–XXaggressive`][196]
        * [5.7.2 析构函数][197]
        * [5.7.3 引用对象][198]
        * [5.7.4 对象池][199]
        * [5.7.5 算法与数据结构][200]
            * [5.7.5.1 典型问题][201]
            * [5.7.5.2 意料之外的性质][202]
        * [5.7.6 误用`System.gc()`][203]
        * [5.7.7 线程数太多][204]
        * [5.7.8 锁竞争导致性能瓶颈][205]
        * [5.7.9 不必要的异常][206]
        * [5.7.10 大对象][207]
        * [5.7.11 本地内存 vs. 堆内存][208]
    * [5.8 `wait/notify`方法与胖锁][209]
        * [5.8.1 堆的大小设置不当][210]
        * [5.8.2 存活对象过多][211]
        * [5.8.3 Java并非银弹][212]
    * [5.9 小结][213]
* [6 JRockit Mission Control][214]
    * [6.1 相关背景][215]
        * [6.1.1 采样分析 vs. 准确分析][216]
        * [6.1.2 用途广泛][217]
    * [6.2 概述][218]
        * [6.2.1 JRockit Mission Control的服务器端组件][219]
        * [6.2.2 JRockit Mission Control的客户端组件][220]
        * [6.2.3 术语介绍][221]
        * [6.2.4 单独运行JRockit Mission Control][222]
        * [6.2.5 在Eclipse中运行JRockit Mission Control][223]
        * [6.2.6 远程管理JRockit][224]
            * [6.2.6.1 JRockit发现协议（JRockit Discovery Protocol）][225]
        * [6.2.7 安全限制][226]
    * [6.3 处理连接问题][227]
        * [6.3.1 主机名解析失败的问题][228]
    * [6.4 Experimental Update Site][229]
    * [6.5 调试JRockit Mission Control][230]
    * [6.6 小结][231]
* [7 Management Console][232]
    * [7.1 JMX Management Console][233]
    * [7.2 Management Console][234]
        * [7.2.1 一般信息][235]
            * [7.2.1.1 概览][236]
        * [7.2.2 MBean][237]
            * [7.2.2.1 MBean浏览器][238]
            * [7.2.2.2 触发器][239]
        * [7.2.3 运行时][240]
            * [7.2.3.1 系统标签页][241]
            * [7.2.3.2 内存标签页][242]
            * [7.2.3.3 线程标签页][243]
        * [7.2.4 高级标签组][244]
            * [7.2.4.1 方法概要分析][245]
            * [7.2.4.2 异常标签页][246]
            * [7.2.4.3 诊断命令标签页][247]
        * [7.2.5 其他标签组][248]
            * [7.2.5.1 JConsole][249]
    * [7.3 扩展JRockit Mission Control Console][250]
    * [7.4 小结][251]
* [8 运行时分析器][252]
    * [8.1 反馈信息的必要性][253]
        * [8.1.1 记录][254]
    * [8.2 分析JRA记录][255]
        * [8.2.1 General标签组][256]
            * [8.2.1.1 Overview标签页][257]
            * [8.2.1.2 Recoding标签页][258]
            * [8.2.1.3 System标签页][259]
        * [8.2.2 Memory标签组][260]
            * [8.2.2.1 Overview标签页][261]
            * [8.2.2.2 GC标签页][262]
            * [8.2.2.3 GC统计信息标签页][263]
            * [8.2.2.4 内存分配标签页][264]
            * [8.2.2.5 堆信息标签页][265]
            * [8.2.2.6 对象统计标签页][266]
        * [8.2.3 代码标签组][267]
            * [8.2.3.1 概览标签页][268]
            * [8.2.3.2 热点方法标签页][269]
            * [8.2.3.3 优化标签页][270]
        * [8.2.4 线程/锁标签组][271]
            * [8.2.4.1 概览标签页][272]
            * [8.2.4.2 线程标签页][273]
            * [8.2.4.3 Java锁标签页][274]
            * [8.2.4.4 JVM锁标签页][275]
            * [8.2.4.5 线程转储标签页][276]
        * [8.2.5 延迟标签组][277]
            * [8.2.5.1 概览标签页][278]
            * [8.2.5.2 日志标签页][279]
            * [8.2.5.3 图形标签页][280]
            * [8.2.5.4 线程标签页][281]
            * [8.2.5.5 堆栈跟踪标签页][282]
            * [8.2.5.6 直方图标签页][283]
        * [8.2.6 使用操作集][284]
    * [8.3 故障排除][285]
    * [8.4 小结][286]
* [9 飞行记录仪][287]
    * [9.1 JRA进化][288]
        * [9.1.1 关于事件][289]
        * [9.1.2 记录引擎][290]
        * [9.1.3 启动参数][291]
            * [9.1.3.1 开启基于时间的记录][292]
    * [9.2 在JRockit Mission Control中使用JFR][293]
        * [9.2.1 自定义JFR记录][294]
    * [9.3 与JRA的区别][295]
        * [9.3.1 范围选择器][296]
        * [9.3.2 操作集（Operative Set）][297]
        * [9.3.3 关联键][298]
        * [9.3.4 延迟分析][299]
        * [9.3.5 异常分析][300]
        * [9.3.6 内存分析][301]
    * [9.4 自定义事件][302]
    * [9.5 扩展JFR][303]
    * [9.6 小结][304]
* [10 Memory Leak Detector][305]
    * [10.1 Java内存泄漏][306]
        * [10.1.1 静态编程语言中的内存泄漏][307]
        * [10.1.2 自动内存管理中的内存泄漏][308]
    * [10.2 检测Java中的内存泄漏][309]
    * [10.3 Memleak简介][310]
    * [10.4 追踪内存泄漏][311]
        * [10.4.1 与类载入器相关的信息][312]
    * [10.5 交互式追踪内存泄漏][313]
    * [10.6 通用堆分析器][314]
    * [10.7 追踪内存分配][315]
    * [10.8 问题排查][316]
    * [10.9 小结][317]
* [11 JRCMD][318]
    * [11.1 介绍][319]
    * [11.2 覆盖`SIGQUIT`信号处理句柄][320]
        * [11.2.1 特殊命令][321]
    * [11.3 JRCMD的限制][322]
    * [11.4 JRCMD命令参考][323]
        * [11.4.1 check_flightrecording (R28)][324]
        * [11.4.2 checkjrarecording (R28)][325]
        * [11.4.3 command_line][326]
        * [11.4.4 dump_flightrecording (R28)][327]
        * [11.4.5 heap_diagnostics (R28)][328]
        * [11.4.6 hprofdump (R28)][329]
        * [11.4.7 kill_management_server][330]
        * [11.4.8 list_vmflags (R28)][331]
        * [11.4.9 lockprofile_print][332]
        * [11.4.10 lockprofile_reset][333]
        * [11.4.11 memleakserver][334]
        * [11.4.12 oom_diagnostics (R27)][335]
        * [11.4.13 print_class_summary][336]
        * [11.4.14 print_codegen_list][337]
        * [11.4.15 print_memusage (R27)][338]
        * [11.4.16 print_memusage (R28)][339]
        * [11.4.17 print_object_summary][340]
        * [11.4.18 print_properties][341]
        * [11.4.19 print_threads][342]
        * [11.4.20 print_utf8pool][343]
        * [11.4.21 print_vm_state][344]
        * [11.4.22 run_optfile (R27)][345]
        * [11.4.23 run_optfile (R28)][346]
        * [11.4.24 runfinalization][347]
        * [11.4.25 runsystemgc][348]
        * [11.4.26 set_vmflag (R28)][349]
        * [11.4.27 start_flightrecording (R28)][350]
        * [11.4.28 start_management_server][351]
        * [11.4.29 startjrarecording (R27)][352]
        * [11.4.30 stop_flightrecording (R28)][353]
        * [11.4.31 timestamp][354]
        * [11.4.32 verbosity][355]
        * [11.4.33 version][356]
    * [11.5 小结][357]
* [12 JRockit Management API][358]
    * [12.1 JMAPI][359]
        * [12.1.1 JMAPI示例][360]
    * [12.2 JMXMAPI][361]
        * [12.2.1 JRockit内部性能计数器][362]
        * [12.2.2 使用JMXMAPI构建可远程操作的JRCMD][363]
    * [12.3 小结][364]
* [13 JRockit Virtual Edition][365]
    * [13.1 虚拟化简介][366]
        * [13.1.1 全虚拟化][367]
        * [13.1.2 半虚拟化][368]
        * [13.1.3 其他虚拟化术语][369]
        * [13.1.4 虚拟机管理程序][370]
            * [13.1.4.1 托管型虚拟机管理程序][371]
            * [13.1.4.2 本地型虚拟机管理程序][372]
            * [13.1.4.3 市面上其他虚拟机管理程序][373]
        * [13.1.5 虚拟化的优势][374]
        * [13.1.6 虚拟化的劣势][375]
    * [13.2 Java虚拟化][376]
        * [13.2.1 JRockit Virtual Edition][377]
            * [13.2.1.1 JRockit VE内核][378]
        * [13.2.2 虚拟机镜像与管理框架][379]
        * [13.2.3 JRockit VE的优势][380]
            * [13.2.3.1 性能与资源利用率][381]
                * [13.2.3.1.1 移除"虚拟三件套"][382]
                * [13.2.3.1.2 内存使用量][383]
            * [13.2.3.2 可管理性][384]
            * [13.2.3.3 简单又安全][385]
        * [13.2.4 JRockit VE的不足][386]
    * [13.3 虚拟化能媲美真实环境吗？][387]
        * [13.3.1 高质量的热点代码采样][388]
        * [13.3.2 自适应堆大小][389]
        * [13.3.3 线程间的页保护][390]
            * [13.3.3.1 改进垃圾回收][391]
            * [13.3.3.2 并发内存整理][392]
    * [13.4 小结][393]
* [参考文献][394]
* [术语汇编][395]







[1]:    ./chap1/1.md#1                                           "1 起步"
[2]:    ./chap1/1.1.md#1.1                                       "1.1 获得JRockit JVM"
[3]:    ./chap1/1.2.md#1.2                                       "1.2 将应用程序迁移到JRockit"
[4]:    ./chap1/1.2.md#1.2.1                                     "1.2.1 命令行选项"
[5]:    ./chap1/1.2.md#1.2.1.1                                   "1.2.1.1 系统属性"
[6]:    ./chap1/1.2.md#1.2.1.2                                   "1.2.1.2 标准命令行选项"
[7]:    ./chap1/1.2.md#1.2.1.3                                   "1.2.1.3 非标准命令行选项"
[8]:    ./chap1/1.2.md#1.2.2                                     "1.2.2 行为差异"
[9]:    ./chap1/1.3.md#1.3                                       "1.3 JRockit版本号的命名规则"
[10]:   ./chap1/1.4.md#1.4                                       "1.4 获取帮助"
[11]:   ./chap1/1.5.md#1.5                                       "1.5 小结"
[12]:   ./chap2/2.md#2                                           "2 自适应代码生成"
[13]:   ./chap2/2.1.md#2.1                                       "2.1 平台独立性"
[14]:   ./chap2/2.2.md#2.2                                       "2.2 Java虚拟机"
[15]:   ./chap2/2.2.md#2.2.1                                     "2.2.1 基于栈的虚拟机"
[16]:   ./chap2/2.2.md#2.2.2                                     "2.2.2 字节码格式"
[17]:   ./chap2/2.2.md#2.2.2.1                                   "2.2.2.1 操作与操作数"
[18]:   ./chap2/2.2.md#2.2.2.2                                   "2.2.2.2 常量池"
[19]:   ./chap2/2.3.md#2.3                                       "2.3 代码生成策略"
[20]:   ./chap2/2.3.md#2.3.1                                     "2.3.1 纯解释执行"
[21]:   ./chap2/2.3.md#2.3.2                                     "2.3.2 静态编译"
[22]:   ./chap2/2.3.md#2.3.3                                     "2.3.3 完全静态编译"
[23]:   ./chap2/2.3.md#2.3.4                                     "2.3.4 混合模式"
[24]:   ./chap2/2.4.md#2.4                                       "2.4 自适应代码生成"
[25]:   ./chap2/2.4.md#2.4.1                                     "2.4.1 判断热方法"
[26]:   ./chap2/2.4.md#2.4.1.1                                   "2.4.1.1 调用计数器"
[27]:   ./chap2/2.4.md#2.4.1.2                                   "2.4.1.2 基于软件的线程采样"
[28]:   ./chap2/2.4.md#2.4.1.3                                   "2.4.1.3 硬件采样"
[29]:   ./chap2/2.4.md#2.4.2                                     "2.4.2 优化动态程序"
[30]:   ./chap2/2.5.md#2.5                                       "2.5 深入JIT编译器"
[31]:   ./chap2/2.5.md#2.5.1                                     "2.5.1 处理字节码"
[32]:   ./chap2/2.5.md#2.5.1.1                                   "2.5.1.1 字节码混淆"
[33]:   ./chap2/2.5.md#2.5.2                                     "2.5.2 字节码“优化器”"
[34]:   ./chap2/2.5.md#2.5.2.1                                   "2.5.2.1 抽象语法树"
[35]:   ./chap2/2.5.md#2.5.3                                     "2.5.3 优化字节码"
[36]:   ./chap2/2.6.md#2.6                                       "2.6 代码流水线"
[37]:   ./chap2/2.6.md#2.6.1                                     "2.6.1 为什么JRockit没有字节码解释器"
[38]:   ./chap2/2.6.md#2.6.2                                     "2.6.2 启动"
[39]:   ./chap2/2.6.md#2.6.3                                     "2.6.3 运行时代码生成"
[40]:   ./chap2/2.6.md#2.6.3.1                                   "2.6.3.1 Trampolines"
[41]:   ./chap2/2.6.md#2.6.3.2                                   "2.6.3.2 代码生成请求"
[42]:   ./chap2/2.6.md#2.6.3.3                                   "2.6.3.3 代码优化请求"
[43]:   ./chap2/2.6.md#2.6.3.4                                   "2.6.3.4 栈上替换"
[44]:   ./chap2/2.6.md#2.6.3.5                                   "2.6.3.5 簿记"
[45]:   ./chap2/2.6.md#2.6.4                                     "2.6.4 代码生成概述"
[46]:   ./chap2/2.6.md#2.6.4.1                                   "2.6.4.1 代码的中间表示"
[47]:   ./chap2/2.6.md#2.6.4.2                                   "2.6.4.2 JIT编译"
[48]:   ./chap2/2.6.md#2.6.4.3                                   "2.6.4.3 代码优化"
[49]:   ./chap2/2.7.md#2.7                                       "2.7 控制代码生成"
[50]:   ./chap2/2.7.md#2.7.1                                     "2.7.1 命令行选项与指导文件"
[51]:   ./chap2/2.7.md#2.7.1.1                                   "2.7.1.1 命令行选项"
[52]:   ./chap2/2.7.md#2.7.1.2                                   "2.7.1.2 指导文件"
[53]:   ./chap2/2.8.md#2.8                                       "2.8 小结"
[54]:   ./chap3/3.md#3                                           "3 自适应内存管理"
[55]:   ./chap3/3.1.md#3.1                                       "3.1 自动内存管理相关概念"
[56]:   ./chap3/3.1.md#3.1.1                                     "3.1.1 自适应内存管理"
[57]:   ./chap3/3.1.md#3.1.2                                     "3.1.2 自适应内存管理的优点"
[58]:   ./chap3/3.1.md#3.1.3                                     "3.1.3 自适应内存管理的缺点"
[59]:   ./chap3/3.2.md#3.2                                       "3.2 堆管理基础"
[60]:   ./chap3/3.2.md#3.2.1                                     "3.2.1 对象的分配于释放"
[61]:   ./chap3/3.2.md#3.2.2                                     "3.2.2 碎片与整理"
[62]:   ./chap3/3.3.md#3.3                                       "3.3 垃圾回收算法"
[63]:   ./chap3/3.3.md#3.3.1                                     "3.3.1 引用计数"
[64]:   ./chap3/3.3.md#3.3.2                                     "3.3.2 引用跟踪"
[65]:   ./chap3/3.3.md#3.3.2.1                                   "3.3.2.1 标记-清理"
[66]:   ./chap3/3.3.md#3.3.2.2                                   "3.3.2.2 暂停-拷贝"
[67]:   ./chap3/3.3.md#3.3.3                                     "3.3.3 STW(stop-the-world)"
[68]:   ./chap3/3.3.md#3.3.3.1                                   "3.3.3.1 保守式 vs. 准确式"
[69]:   ./chap3/3.3.md#3.3.3.2                                   "3.3.3.2 livemap"
[70]:   ./chap3/3.3.md#3.3.4                                     "3.3.4 分代垃圾回收"
[71]:   ./chap3/3.3.md#3.3.4.1                                   "3.3.4.1 多个新生代的内存排布"
[72]:   ./chap3/3.3.md#3.3.4.2                                   "3.3.4.2 写屏障"
[73]:   ./chap3/3.3.md#3.3.5                                     "3.3.5 吞吐量 vs. 延迟"
[74]:   ./chap3/3.3.md#3.3.5.1                                   "3.3.5.1 优化吞吐量"
[75]:   ./chap3/3.3.md#3.3.5.2                                   "3.3.5.2 优化延迟"
[76]:   ./chap3/3.3.md#3.3.6                                     "3.3.6 JRockit中的垃圾回收"
[77]:   ./chap3/3.3.md#3.3.6.1                                   "3.3.6.1 老年代垃圾回收"
[78]:   ./chap3/3.3.md#3.3.6.2                                   "3.3.6.2 新生代垃圾回收"
[79]:   ./chap3/3.3.md#3.3.6.3                                   "3.3.6.3 永生代垃圾回收"
[80]:   ./chap3/3.3.md#3.3.6.4                                   "3.3.6.4 内存整理"
[81]:   ./chap3/3.4.md#3.4                                       "3.4 性能与伸缩性"
[82]:   ./chap3/3.4.md#3.4.1                                     "3.4.1 线程局部分配"
[83]:   ./chap3/3.4.md#3.4.2                                     "3.4.2 更大的堆内存"
[84]:   ./chap3/3.4.md#3.4.2.1                                   "3.4.2.1 32位架构下的4GB内存限制"
[85]:   ./chap3/3.4.md#3.4.2.2                                   "3.4.2.2 64位架构"
[86]:   ./chap3/3.4.md#3.4.3                                     "3.4.3 缓存友好性"
[87]:   ./chap3/3.4.md#3.4.3.1                                   "3.4.3.1 预抓取"
[88]:   ./chap3/3.4.md#3.4.3.2                                   "3.4.3.2 数据存放"
[89]:   ./chap3/3.4.md#3.4.4                                     "3.4.4 NUMA"
[90]:   ./chap3/3.4.md#3.4.5                                     "3.4.5 大内存页（Large pages）"
[91]:   ./chap3/3.4.md#3.4.6                                     "3.4.6 自适应（Adaptability）"
[92]:   ./chap3/3.5.md#3.5                                       "3.5 近实时垃圾回收"
[93]:   ./chap3/3.5.md#3.5.1                                     "3.5.1 软实时与硬实时"
[94]:   ./chap3/3.5.md#3.5.2                                     "3.5.2 JRockit Real Time"
[95]:   ./chap3/3.5.md#3.5.2.1                                   "3.5.2.1 软实时有效么？"
[96]:   ./chap3/3.5.md#3.5.2.2                                   "3.5.2.2 工作原理"
[97]:   ./chap3/3.6.md#3.6                                       "3.6 内存操作相关的API"
[98]:   ./chap3/3.6.md#3.6.1                                     "3.6.1 析构函数"
[99]:   ./chap3/3.6.md#3.6.2                                     "3.6.2 Java中的引用"
[100]:  ./chap3/3.6.md#3.6.2.1                                   "3.6.2.1 弱引用"
[101]:  ./chap3/3.6.md#3.6.2.2                                   "3.6.2.2 软引用"
[102]:  ./chap3/3.6.md#3.6.2.3                                   "3.6.2.3 虚引用"
[103]:  ./chap3/3.6.md#3.6.3                                     "3.6.3 JVM的行为差异"
[104]:  ./chap3/3.7.md#3.7                                       "3.7 陷阱与伪优化"
[105]:  ./chap3/3.7.md#3.7.1                                     "3.7.1 Java不是C++"
[106]:  ./chap3/3.8.md#3.8                                       "3.8 JRockit中的内存管理"
[107]:  ./chap3/3.8.md#3.8.1                                     "3.8.1 基本参数"
[108]:  ./chap3/3.8.md#3.8.1.1                                   "3.8.1.1 打印垃圾回收日志"
[109]:  ./chap3/3.8.md#3.8.1.2                                   "3.8.1.2 设置堆的初始值和最大值"
[110]:  ./chap3/3.8.md#3.8.1.3                                   "3.8.1.3 设置垃圾回收器的执行目标"
[111]:  ./chap3/3.8.md#3.8.1.4                                   "3.8.1.4 指定垃圾回收策略"
[112]:  ./chap3/3.8.md#3.8.2                                     "3.8.2 压缩引用"
[113]:  ./chap3/3.8.md#3.8.3                                     "3.8.3 高级选项"
[114]:  ./chap3/3.9.md#3.9                                       "3.9 小结"
[115]:  ./chap4/4.md#4                                           "4 线程与同步"
[116]:  ./chap4/4.1.md#4.1                                       "4.1 基本概念"
[117]:  ./cgap4/4.1.md#4.1.1                                     "4.1.1 难以调试"
[118]:  ./chap4/4.1.md#4.1.2                                     "4.1.2 难以优化"
[119]:  ./chap4/4.1.md#4.1.2.1                                   "4.1.2.1 延迟分析"
[120]:  ./chap4/4.2.md#4.2                                       "4.2 Java API"
[121]:  ./chap4/4.2.md#4.2.1                                     "4.2.1 synchronized关键字"
[122]:  ./chap4/4.2.md#4.2.2                                     "4.2.2 java.lang.Thread类"
[123]:  ./chap4/4.2.md#4.2.3                                     "4.2.3 java.util.concurrent包"
[124]:  ./chap4/4.2.md#4.2.4                                     "4.2.4 信号量"
[125]:  ./chap4/4.2.md#4.2.5                                     "4.2.5 volatile关键字"
[126]:  ./chap4/4.3.md#4.3                                       "4.3 Java中线程与同步机制的实现"
[127]:  ./chap4/4.3.md#4.3.1                                     "4.3.1 Java内存模型"
[128]:  ./chap4/4.3.md#4.3.1.1                                   "4.3.1.1 早期内存模型中的问题"
[129]:  ./chap4/4.3.md#4.3.1.2                                   "4.3.1.2 JSR-133"
[130]:  ./chap4/4.3.md#4.3.2                                     "4.3.2 同步的实现"
[131]:  ./chap4/4.3.md#4.3.2.1                                   "4.3.2.1 原生机制"
[132]:  ./chap4/4.3.md#4.3.2.2                                   "4.3.2.2 锁(Lock)"
[133]:  ./chap4/4.3.md#4.3.3                                     "4.3.3 同步在字节码中的实现"
[134]:  ./chap4/4.3.md#4.3.3.1                                   "4.3.3.1 匹配的锁操作"
[135]:  ./chap4/4.3.md#4.3.4                                     "4.3.4 线程的实现"
[136]:  ./chap4/4.3.md#4.3.4.1                                   "4.3.4.1 绿色线程（green thread）"
[137]:  ./chap4/4.3.md#4.3.4.2                                   "4.3.4.2 操作系统线程"
[138]:  ./chap4/4.4.md#4.4                                       "4.4 对于线程与同步的优化"
[139]:  ./chap4/4.4.md#4.4.1                                     "4.4.1 锁膨胀与锁收缩"
[140]:  ./chap4/4.4.md#4.4.2                                     "4.4.2 递归锁"
[141]:  ./chap4/4.4.md#4.4.3                                     "4.4.3 锁融合"
[142]:  ./chap4/4.4.md#4.4.4                                     "4.4.4 延迟解锁"
[143]:  ./chap4/4.4.md#4.4.4.1                                   "4.4.4.1 实现"
[144]:  ./chap4/4.4.md#4.4.4.2                                   "4.4.4.2 禁用对象"
[145]:  ./chap4/4.4.md#4.4.4.3                                   "4.4.4.3 禁用类"
[146]:  ./chap4/4.4.md#4.4.4.4                                   "4.4.4.4 结论"
[147]:  ./chap4/4.5.md#4.5                                       "4.5 陷阱与伪优化"
[148]:  ./chap4/4.5.md#4.5.1                                     "4.5.1 问题方法：`Thread.stop` `Thread.resume` `Thread.suspend`"
[149]:  ./chap4/4.5.md#4.5.2                                     "4.5.2 双检查锁"
[150]:  ./chap4/4.6.md#4.6                                       "4.6 相关命令行参数"
[151]:  ./chap4/4.6.md#4.6.1                                     "4.6.1 检查锁与延迟解锁"
[152]:  ./chap4/4.6.md#4.6.1.1                                   "4.6.1.1 使用`-Xverbose:locks`参数分析锁的行为"
[153]:  ./chap4/4.6.md#4.6.1.2                                   "4.6.1.2 使用参数`-XX:UseLazyUnlocking`"
[154]:  ./chap4/4.6.md#4.6.2                                     "4.6.2 输出调用栈信息"
[155]:  ./chap4/4.6.md#4.6.3                                     "4.6.3 锁分析"
[156]:  ./chap4/4.6.md#4.6.3.1                                   "4.6.3.1 使用参数`-XX:UseLockProfiling`进行所分析"
[157]:  ./chap4/4.6.md#4.6.4                                     "4.6.4 设置线程栈的大小"
[158]:  ./chap4/4.6.md#4.6.5                                     "4.6.5 使用命令行参数控制锁的行为"
[159]:  ./chap4/4.7.md#4.7                                       "4.7 小结"
[160]:  ./chap5/5.md#5                                           "5 基准测试与性能调优"
[161]:  ./chap5/5.1.md#5.1                                       "5.1 为何要进行基准测试"
[162]:  ./chap5/5.1.md#5.1.1                                     "5.1.1 制定性能目标"
[163]:  ./chap5/5.1.md#5.1.2                                     "5.1.2 对性能进行回归测试"
[164]:  ./chap5/5.1.md#5.1.3                                     "5.1.3 确定优化方向"
[165]:  ./chap5/5.1.md#5.1.4                                     "5.1.4 商业应用"
[166]:  ./chap5/5.2.md#5.2                                       "5.2 如何构建基准测试"
[167]:  ./chap5/5.2.md#5.2.1                                     "5.2.1 "置身事外（outside the system）""
[168]:  ./chap5/5.2.md#5.2.2                                     "5.2.2 测量时间"
[169]:  ./chap5/5.2.md#5.2.3                                     "5.2.3 微基准测试（micro benchmark）"
[170]:  ./chap5/5.2.md#5.2.3.1                                   "5.2.3.1 基准测试与栈上替换"
[171]:  ./chap5/5.2.md#5.2.3.2                                   "5.2.3.2 基准测试与启动时间"
[172]:  ./chap5/5.2.md#5.2.4                                     "5.2.4 测试前要热身"
[173]:  ./chap5/5.3.md#5.3                                       "5.3 确定测试目标"
[174]:  ./chap5/5.3.md#5.3.1                                     "5.3.1 吞吐量"
[175]:  ./chap5/5.3.md#5.3.2                                     "5.3.2 兼顾吞吐量、响应时间和延迟"
[176]:  ./chap5/5.3.md#5.3.3                                     "5.3.3 伸缩性"
[177]:  ./chap5/5.3.md#5.3.4                                     "5.3.4 能源消耗"
[178]:  ./chap5/5.3.md#5.3.5                                     "5.3.5 其他方面"
[179]:  ./chap5/5.4.md#5.4                                       "5.4 工业级基准测试"
[180]:  ./chap5/5.4.md#5.4.1                                     "5.4.1 SPEC基准测试套件"
[181]:  ./chap5/5.4.md#5.4.1.1                                   "5.4.1.1 SPECjvm基准测试套件"
[182]:  ./chap5/5.4.md#5.4.1.2                                   "5.4.1.2 SPECjAppServer套件/SPECjEnterprise2010套件"
[183]:  ./chap5/5.4.md#5.4.1.3                                   "5.4.1.3 SPECjbb套件"
[184]:  ./chap5/5.4.md#5.4.2                                     "5.4.2 SipStone基准测试"
[185]:  ./chap5/5.4.md#5.4.3                                     "5.4.3 DaCapo基准测试"
[186]:  ./chap5/5.4.md#5.4.4                                     "5.4.4 真实场景下的应用程序"
[187]:  ./chap5/5.5.md#5.5                                       "5.5 基准测试的潜在风险"
[188]:  ./chap5/5.6.md#5.6                                       "5.6 性能调优"
[189]:  ./chap5/5.6.md#5.6.1                                     "5.6.1 非规范化行为（Out of the box behavior）"
[190]:  ./chap5/5.6.md#5.6.2                                     "5.6.2 调优目标"
[191]:  ./chap5/5.6.md#5.6.2.1                                   "5.6.2.1 内存管理调优"
[192]:  ./chap5/5.6.md#5.6.2.2                                   "5.6.2.2 代码生成调优"
[193]:  ./chap5/5.6.md#5.6.2.3                                   "5.6.2.3 锁与线程调优"
[194]:  ./chap5/5.6.md#5.6.2.4                                   "5.6.2.4 其他相关调优"
[195]:  ./chap5/5.7.md#5.7                                       "5.7 常见性能瓶颈与规避方法"
[196]:  ./chap5/5.7.md#5.7.1                                     "5.7.1 命令行参数`–XXaggressive`"
[197]:  ./chap5/5.7.md#5.7.2                                     "5.7.2 析构函数"
[198]:  ./chap5/5.7.md#5.7.3                                     "5.7.3 引用对象"
[199]:  ./chap5/5.7.md#5.7.4                                     "5.7.4 对象池"
[200]:  ./chap5/5.7.md#5.7.5                                     "5.7.5 算法与数据结构"
[201]:  ./chap5/5.7.md#5.7.5.1                                   "5.7.5.1 典型问题"
[202]:  ./chap5/5.7.md#5.7.5.2                                   "5.7.5.2 意料之外的性质"
[203]:  ./chap5/5.7.md#5.7.6                                     "5.7.6 误用`System.gc()`"
[204]:  ./chap5/5.7.md#5.7.7                                     "5.7.7 线程数太多"
[205]:  ./chap5/5.7.md#5.7.8                                     "5.7.8 锁竞争导致性能瓶颈"
[206]:  ./chap5/5.7.md#5.7.9                                     "5.7.9 不必要的异常"
[207]:  ./chap5/5.7.md#5.7.10                                    "5.7.10 大对象"
[208]:  ./chap5/5.7.md#5.7.11                                    "5.7.11 本地内存 vs. 堆内存"
[209]:  ./chap5/5.8.md#5.8                                       "5.8 `wait/notify`方法与胖锁"
[210]:  ./chap5/5.8.md#5.8.1                                     "5.8.1 堆的大小设置不当"
[211]:  ./chap5/5.8.md#5.8.2                                     "5.8.2 存活对象过多"
[212]:  ./chap5/5.8.md#5.8.3                                     "5.8.3 Java并非银弹"
[213]:  ./chap5/5.9.md#5.9                                       "5.9 小结"
[214]:  ./chap6/6.md#6                                           "6 JRockit Mission Control"
[215]:  ./chap6/6.1.md#6.1                                       "6.1 相关背景"
[216]:  ./chap6/6.1.md#6.1.1                                     "6.1.1 采样分析 vs. 准确分析"
[217]:  ./chap6/6.1.md#6.1.2                                     "6.1.2 用途广泛"
[218]:  ./chap6/6.2.md#6.2                                       "6.2 概述"
[219]:  ./chap6/6.2.md#6.2.1                                     "6.2.1 JRockit Mission Control的服务器端组件"
[220]:  ./chap6/6.2.md#6.2.2                                     "6.2.2 JRockit Mission Control的客户端组件"
[221]:  ./chap6/6.2.md#6.2.3                                     "6.2.3 术语介绍"
[222]:  ./chap6/6.2.md#6.2.4                                     "6.2.4 单独运行JRockit Mission Control"
[223]:  ./chap6/6.2.md#6.2.5                                     "6.2.5 在Eclipse中运行JRockit Mission Control"
[224]:  ./chap6/6.2.md#6.2.6                                     "6.2.6 远程管理JRockit"
[225]:  ./chap6/6.2.md#6.2.6.1                                   "6.2.6.1 JRockit发现协议（JRockit Discovery Protocol）"
[226]:  ./chap6/6.2.md#6.2.7                                     "6.2.7 安全限制"
[227]:  ./chap6/6.3.md#6.3                                       "6.3 处理连接问题"
[228]:  ./chap6/6.3.md#6.3.1                                     "6.3.1 主机名解析失败的问题"
[229]:  ./chap6/6.4.md#6.4                                       "6.4 Experimental Update Site"
[230]:  ./chap6/6.5.md#6.5                                       "6.5 调试JRockit Mission Control"
[231]:  ./chap6.6.6.md#6.6                                       "6.6 小结"
[232]:  ./chap7/7.md#7                                           "7 Management Console"
[233]:  ./chap7/7.1.md#7.1                                       "7.1 JMX Management Console"
[234]:  ./chap7/7.2.md#7.2                                       "7.2 Management Console"
[235]:  ./chap7/7.2.md#7.2.1                                     "7.2.1 一般信息"
[236]:  ./chap7/7.2.md#7.2.1.1                                   "7.2.1.1 概览"
[237]:  ./chap7/7.2.md#7.2.2                                     "7.2.2 MBean"
[238]:  ./chap7/7.2.md#7.2.2.1                                   "7.2.2.1 MBean浏览器"
[239]:  ./chap7/7.2.md#7.2.2.2                                   "7.2.2.2 触发器"
[240]:  ./chap7/7.2.md#7.2.3                                     "7.2.3 运行时"
[241]:  ./chap7/7.2.md#7.2.3.1                                   "7.2.3.1 系统标签页"
[242]:  ./chap7/7.2.md#7.2.3.2                                   "7.2.3.2 内存标签页"
[243]:  ./chap7/7.2.md#7.2.3.3                                   "7.2.3.3 线程标签页"
[244]:  ./chap7/7.2.md#7.2.4                                     "7.2.4 高级标签组"
[245]:  ./chap7/7.2.md#7.2.4.1                                   "7.2.4.1 方法概要分析"
[246]:  ./chap7/7.2.md#7.2.4.2                                   "7.2.4.2 异常标签页"
[247]:  ./chap7/7.2.md#7.2.4.3                                   "7.2.4.3 诊断命令标签页"
[248]:  ./chap7/7.2.md#7.2.5                                     "7.2.5 其他标签组"
[249]:  ./chap7/7.2.md#7.2.5.1                                   "7.2.5.1 JConsole"
[250]:  ./chap7/7.3.md#7.3                                       "7.3 扩展JRockit Mission Control Console"
[251]:  ./chap7/7.4.md#7.4                                       "7.4 小结"
[252]:  ./chap8/8.md#8                                           "8 运行时分析器"
[253]:  ./chap8/8.1.md#8.1                                       "8.1 反馈信息的必要性"
[254]:  ./chap8/8.1.md#8.1.1                                     "8.1.1 记录"
[255]:  ./chap8/8.2.md#8.2                                       "8.2 分析JRA记录"
[256]:  ./chap8/8.2.md#8.2.1                                     "8.2.1 General标签组"
[257]:  ./chap8/8.2.md#8.2.1.1                                   "8.2.1.1 Overview标签页"
[258]:  ./chap8/8.2.md#8.2.1.2                                   "8.2.1.2 Recoding标签页"
[259]:  ./chap8/8.2.md#8.2.1.3                                   "8.2.1.3 System标签页"
[260]:  ./chap8/8.2.md#8.2.2                                     "8.2.2 Memory标签组"
[261]:  ./chap8/8.2.md#8.2.2.1                                   "8.2.2.1 Overview标签页"
[262]:  ./chap8/8.2.md#8.2.2.2                                   "8.2.2.2 GC标签页"
[263]:  ./chap8/8.2.md#8.2.2.3                                   "8.2.2.3 GC统计信息标签页"
[264]:  ./chap8/8.2.md#8.2.2.4                                   "8.2.2.4 内存分配标签页"
[265]:  ./chap8/8.2.md#8.2.2.5                                   "8.2.2.5 堆信息标签页"
[266]:  ./chap8/8.2.md#8.2.2.6                                   "8.2.2.6 对象统计标签页"
[267]:  ./chap8/8.2.md#8.2.3                                     "8.2.3 代码标签组"
[268]:  ./chap8/8.2.md#8.2.3.1                                   "8.2.3.1 概览标签页"
[269]:  ./chap8/8.2.md#8.2.3.2                                   "8.2.3.2 热点方法标签页"
[270]:  ./chap8/8.2.md#8.2.3.3                                   "8.2.3.3 优化标签页"
[271]:  ./chap8/8.2.md#8.2.4                                     "8.2.4 线程/锁标签组"
[272]:  ./chap8/8.2.md#8.2.4.1                                   "8.2.4.1 概览标签页"
[273]:  ./chap8/8.2.md#8.2.4.2                                   "8.2.4.2 线程标签页"
[274]:  ./chap8/8.2.md#8.2.4.3                                   "8.2.4.3 Java锁标签页"
[275]:  ./chap8/8.2.md#8.2.4.4                                   "8.2.4.4 JVM锁标签页"
[276]:  ./chap8/8.2.md#8.2.4.5                                   "8.2.4.5 线程转储标签页"
[277]:  ./chap8/8.2.md#8.2.5                                     "8.2.5 延迟标签组"
[278]:  ./chap8/8.2.md#8.2.5.1                                   "8.2.5.1 概览标签页"
[279]:  ./chap8/8.2.md#8.2.5.2                                   "8.2.5.2 日志标签页"
[280]:  ./chap8/8.2.md#8.2.5.3                                   "8.2.5.3 图形标签页"
[281]:  ./chap8/8.2.md#8.2.5.4                                   "8.2.5.4 线程标签页"
[282]:  ./chap8/8.2.md#8.2.5.5                                   "8.2.5.5 堆栈跟踪标签页"
[283]:  ./chap8/8.2.md#8.2.5.6                                   "8.2.5.6 直方图标签页"
[284]:  ./chap8/8.2.md#8.2.6                                     "8.2.6 使用操作集"
[285]:  ./chap8/8.3.md#8.3                                       "8.3 故障排除"
[286]:  ./chap8/8.4.md#8.4                                       "8.4 小结"
[287]:  ./chap9/9.md#9                                           "9 飞行记录仪"
[288]:  ./chap9/9.1.md#9.1                                       "9.1 JRA进化"
[289]:  ./chap9/9.1.md#9.1.1                                     "9.1.1 关于事件"
[290]:  ./chap9/9.1.md#9.1.2                                     "9.1.2 记录引擎"
[291]:  ./chap9/9.1.md#9.1.3                                     "9.1.3 启动参数"
[292]:  ./chap9/9.1.md#9.1.3.1                                   "9.1.3.1 开启基于时间的记录"
[293]:  ./chap9/9.2.md#9.2                                       "9.2 在JRockit Mission Control中使用JFR"
[294]:  ./chap9/9.2.md#9.2.1                                     "9.2.1 自定义JFR记录"
[295]:  ./chap9/9.3.md#9.3                                       "9.3 与JRA的区别"
[296]:  ./chap9/9.3.md#9.3.1                                     "9.3.1 范围选择器"
[297]:  ./chap9/9.3.md#9.3.2                                     "9.3.2 操作集（Operative Set）"
[298]:  ./chap9/9.3.md#9.3.3                                     "9.3.3 关联键"
[299]:  ./chap9/9.3.md#9.3.4                                     "9.3.4 延迟分析"
[300]:  ./chap9/9.3.md#9.3.5                                     "9.3.5 异常分析"
[301]:  ./chap9/9.3.md#9.3.6                                     "9.3.6 内存分析"
[302]:  ./chap9/9.4.md#9.4                                       "9.4 自定义事件"
[303]:  ./chap9/9.5.md#9.5                                       "9.5 扩展JFR"
[304]:  ./chap9/9.6.md#9.6                                       "9.6 小结"
[305]:  ./chap10/10.md#10                                        "10 Memory Leak Detector"
[306]:  ./chap10/10.1.md#10.1                                    "10.1 Java内存泄漏"
[307]:  ./chap10/10.1.md#10.1.1                                  "10.1.1 静态编程语言中的内存泄漏"
[308]:  ./chap10/10.1.md#10.1.2                                  "10.1.2 自动内存管理中的内存泄漏"
[309]:  ./chap10/10.2.md#10.2                                    "10.2 检测Java中的内存泄漏"
[310]:  ./chap10/10.3.md#10.3                                    "10.3 Memleak简介"
[311]:  ./chap10/10.4.md#10.4                                    "10.4 追踪内存泄漏"
[312]:  ./chap10/10.4.md#10.4.1                                  "10.4.1 与类载入器相关的信息"
[313]:  ./chap10/10.5.md#10.5                                    "10.5 交互式追踪内存泄漏"
[314]:  ./chap10/10.6.md#10.6                                    "10.6 通用堆分析器"
[315]:  ./chap10/10.7.md#10.7                                    "10.7 追踪内存分配"
[316]:  ./chap10/10.8.md#10.8                                    "10.8 问题排查"
[317]:  ./chap10/10.9.md#10.9                                    "10.9 小结"
[318]:  ./chap11/11.md#11                                        "11 JRCMD"
[319]:  ./chap11/11.1.md#11.1                                    "11.1 介绍"
[320]:  ./chap11/11.2.md#11.2                                    "11.2 覆盖`SIGQUIT`信号处理句柄"
[321]:  ./chap11/11.2.md#11.2.1                                  "11.2.1 特殊命令"
[322]:  ./chap11/11.3.md#11.3                                    "11.3 JRCMD的限制"
[323]:  ./chap11/11.4.md#11.4                                    "11.4 JRCMD命令参考"
[324]:  ./chap11/11.4.md#11.4.1                                  "11.4.1 check_flightrecording (R28)"
[325]:  ./chap11/11.4.md#11.4.2                                  "11.4.2 checkjrarecording (R28)"
[326]:  ./chap11/11.4.md#11.4.3                                  "11.4.3 command_line"
[327]:  ./chap11/11.4.md#11.4.4                                  "11.4.4 dump_flightrecording (R28)"
[328]:  ./chap11/11.4.md#11.4.5                                  "11.4.5 heap_diagnostics (R28)"
[329]:  ./chap11/11.4.md#11.4.6                                  "11.4.6 hprofdump (R28)"      
[330]:  ./chap11/11.4.md#11.4.7                                  "11.4.7 kill_management_server"
[331]:  ./chap11/11.4.md#11.4.8                                  "11.4.8 list_vmflags (R28)"
[332]:  ./chap11/11.4.md#11.4.9                                  "11.4.9 lockprofile_print"
[333]:  ./chap11/11.4.md#11.4.10                                 "11.4.10 lockprofile_reset"
[334]:  ./chap11/11.4.md#11.4.11                                 "11.4.11 memleakserver"
[335]:  ./chap11/11.4.md#11.4.12                                 "11.4.12 oom_diagnostics (R27)"
[336]:  ./chap11/11.4.md#11.4.13                                 "11.4.13 print_class_summary"
[337]:  ./chap11/11.4.md#11.4.14                                 "11.4.14 print_codegen_list"
[338]:  ./chap11/11.4.md#11.4.15                                 "11.4.15 print_memusage (R27)"
[339]:  ./chap11/11.4.md#11.4.16                                 "11.4.16 print_memusage (R28)"
[340]:  ./chap11/11.4.md#11.4.17                                 "11.4.17 print_object_summary"
[341]:  ./chap11/11.4.md#11.4.18                                 "11.4.18 print_properties"
[342]:  ./chap11/11.4.md#11.4.19                                 "11.4.19 print_threads"
[343]:  ./chap11/11.4.md#11.4.20                                 "11.4.20 print_utf8pool"
[344]:  ./chap11/11.4.md#11.4.21                                 "11.4.21 print_vm_state"
[345]:  ./chap11/11.4.md#11.4.22                                 "11.4.22 run_optfile (R27)"
[346]:  ./chap11/11.4.md#11.4.23                                 "11.4.23 run_optfile (R28)"
[347]:  ./chap11/11.4.md#11.4.24                                 "11.4.24 runfinalization"
[348]:  ./chap11/11.4.md#11.4.25                                 "11.4.25 runsystemgc"
[349]:  ./chap11/11.4.md#11.4.26                                 "11.4.26 set_vmflag (R28)"
[350]:  ./chap11/11.4.md#11.4.27                                 "11.4.27 start_flightrecording (R28)"
[351]:  ./chap11/11.4.md#11.4.28                                 "11.4.28 start_management_server"
[352]:  ./chap11/11.4.md#11.4.29                                 "11.4.29 startjrarecording (R27)"
[353]:  ./chap11/11.4.md#11.4.30                                 "11.4.30 stop_flightrecording (R28)"
[354]:  ./chap11/11.4.md#11.4.31                                 "11.4.31 timestamp"
[355]:  ./chap11/11.4.md#11.4.32                                 "11.4.32 verbosity"
[356]:  ./chap11/11.4.md#11.4.33                                 "11.4.33 version"
[357]:  ./chap11/11.5.md#11.5                                    "11.5 小结"
[358]:  ./chap12/12.md#12                                        "12 JRockit Management API"
[359]:  ./chap12/12.1.md#12.1                                    "12.1 JMAPI"
[360]:  ./chap12/12.1.md#12.1.1                                  "12.1.1 JMAPI示例"
[361]:  ./chap12/12.2.md#12.2                                    "12.2 JMXMAPI"
[362]:  ./chap12/12.2.md#12.2.1                                  "12.2.1 JRockit内部性能计数器"
[363]:  ./chap12/12.2.md#12.2.2                                  "12.2.2 使用JMXMAPI构建可远程操作的JRCMD"
[364]:  ./chap12/12.3.md#12.3                                    "12.3 小结"
[365]:  ./chap13/13.md#13                                        "13 JRockit Virtual Edition"
[366]:  ./chap13/13.1.md#13.1                                    "13.1 虚拟化简介"
[367]:  ./chap13/13.1.md#13.1.1                                  "13.1.1 全虚拟化"
[368]:  ./chap13/13.1.md#13.1.2                                  "13.1.2 半虚拟化"
[369]:  ./chap13/13.1.md#13.1.3                                  "13.1.3 其他虚拟化术语"
[370]:  ./chap13/13.1.md#13.1.4                                  "13.1.4 虚拟机管理程序"
[371]:  ./chap13/13.1.md#13.1.4.1                                "13.1.4.1 托管型虚拟机管理程序"
[372]:  ./chap13/13.1.md#13.1.4.2                                "13.1.4.2 本地型虚拟机管理程序"
[373]:  ./chap13/13.1.md#13.1.4.3                                "13.1.4.3 市面上其他虚拟机管理程序"
[374]:  ./chap13/13.1.md#13.1.5                                  "13.1.5 虚拟化的优势"
[375]:  ./chap13/13.1.md#13.1.6                                  "13.1.6 虚拟化的劣势"
[376]:  ./chap13/13.2.md#13.2                                    "13.2 Java虚拟化"
[377]:  ./chap13/13.2.md#13.2.1                                  "13.2.1 JRockit Virtual Edition"
[378]:  ./chap13/13.2.md#13.2.1.1                                "13.2.1.1 JRockit VE内核"
[379]:  ./chap13/13.2.md#13.2.2                                  "13.2.2 虚拟机镜像与管理框架"
[380]:  ./chap13/13.2.md#13.2.3                                  "13.2.3 JRockit VE的优势"
[381]:  ./chap13/13.2.md#13.2.3.1                                "13.2.3.1 性能与资源利用率"
[382]:  ./chap13/13.2.md#13.2.3.1.1                              "13.2.3.1.1 移除"虚拟三件套""
[383]:  ./chap13/13.2.md#13.2.3.1.2                              "13.2.3.1.2 内存使用量"
[384]:  ./chap13/13.2.md#13.2.3.2                                "13.2.3.2 可管理性"
[385]:  ./chap13/13.2.md#13.2.3.3                                "13.2.3.3 简单又安全"
[386]:  ./chap13/13.2.md#13.2.4                                  "13.2.4 JRockit VE的不足"
[387]:  ./chap13/13.3.md#13.3                                    "13.3 虚拟化能媲美真实环境吗？"
[388]:  ./chap13/13.3.md#13.3.1                                  "13.3.1 高质量的热点代码采样"
[389]:  ./chap13/13.3.md#13.3.2                                  "13.3.2 自适应堆大小"
[390]:  ./chap13/13.3.md#13.3.3                                  "13.3.3 线程间的页保护"
[391]:  ./chap13/13.3.md#13.3.3.1                                "13.3.3.1 改进垃圾回收"
[392]:  ./chap13/13.3.md#13.3.3.2                                "13.3.3.2 并发内存整理"
[393]:  ./chap13/13.4.md#13.4                                    "13.4 小结"
[394]:  ./appendix_a_bibliography.md#appendix_a_bibliography     "参考文献"
[395]:  ./appendix_a_bibliography.md#appendix_b_glossary         "术语汇编"
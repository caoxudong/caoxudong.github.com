---
title:      Intel微处理器寄存器简介
category:   blog
layout:     post
tags:       [intel, miscroprocessor, register, assembly]
---


>这里的内容主要来自于《Intel微处理器》和网络的文章

# 寄存器分类

## 通用寄存器

>**RAX（累加器）** RAX可作为64位寄存器（RAX）、32位寄存器（EAX）、16位寄存器（AX）或两个8位寄存器（AH或AL）引用。注意，如果是8位或16位寻址，则只改变32位寄存器的一部分，其余部分不受影响。累加器用于乘法、除法及一些调整指令。对于这些指令，累加器有专门用途，但它通常被认为是多功能寄存器。在80386及更高型号的微处理器中，EAX寄存器也可以保存访问存储单元的偏移地址。在64位的Pentium 4和Core2中，RAX寄存器可保持64位的偏移地址，可以通过40位地址总线访问1TB的存储器。未来Intel计划扩展到52位地址总线访问4PB的存储器。
>
>**RBX（基址）** RBX可作为RBX、EBX、BX、BH或BL寻址。在所有型号的微处理器中，RBX有时用于保存访问存储单元的偏移地址。在80386及更高型号的微处理器中，EBX也能寻址存储器数据。在64位的Pentium 4和Core2中，RBX也能寻址存储器数据。
>
>**RCX（计数）** RCX可作为RCX、ECX、CX、CH或CL寻址，它是个通用寄存器，也可保存许多指令的计数值。在80386及更高型号的微处理器中，ECX寄存器也可保存访问存储器数据的偏移地址。64位的Pentium 4中，RCX也可以寻址存储器数据。用于计数的指令是重复的串指令（REP/REPE/REPNE）以及移位、循环和LOOP/LOOPD指令。移位和循环指令用CL计数，重复的串指令用CX计数，LOOP/LOOPD指令用CX或ECX计数。如果以64位模式操作，LOOP指令使用64位RCX寄存器进行循环计数。
>
>**RDX（数据）** RDX可作为RDX、EDX、DX、DH或DL寻址，它是通用寄存器，用于保存乘法形成的部分结果，或者除法之前的部分被除数。对于80386及更高型号的微处理器，这个寄存器也可寻址存储器数据。
>
>**RBP（基指针）** RBP可作为RBP、EBP或BP寻址，在所有型号的微处理器中，为了传送存储器数据，RBP指向存储单元。
>
>**RDI（目的变址）** RDI可作为RDI、EDI或DI寻址，它常用于寻址串指令的目的数据串。
>
>**RSI（源变址）** RSI可作为RSI、ESI或SI使用。源变址寄存器通常为串指令寻址源数据串。如同RDI一样，RSI也作为通用寄存器使用。如果它作为16位寄存器，就由SI寻址；如果作为32位寄存器，就由ESI寻址；如果作为64位寄存器，就由RSI寻址。
>
>**R8~R15** 这些寄存器只存在于Pentium 4和Core2中64位扩展允许的情况下。如前所述，这些寄存器中的数据是用于通用目的的，按照64、32、16或8位大小寻址。直到64位处理器广泛使用，大部分应用程序才会使用这些寄存器。请注意8位部分只是寄存器中最右边的8位，第8位第15位不按照一个字节直接寻址。

## 专用寄存器

>专用寄存器包括： RIP、RSP和RFLAGS以及段寄存器CS、DS、ES、SS、FS和GS。
>
>**RIP（指令指针）** RIP寻址代码段存储区内的下一条指令。当微处理器工作在实模式下时，这个寄存器是IP（16位）；当80386及更高型号的微处理器工作于保护模式下时，则是EIP（32位）。注意，8086、8088和80286不包含EIP寄存器，而且只有80286及更高型号的微处理器可以工作于保护模式。指令指针指向程序的下一条指令，用于微处理器在程序中顺序地寻址代码段内的下一条指令。指令指针也可由转移指令或调用指令修改。在64位模式中，RIP包含40位地址总线，可用于寻址1TB平展模式地址空间。
>
>**RSP（堆栈指针）** RSP寻址一个称为堆栈的存储区。通过这个指针存取堆栈存储器数据，具体操作将在本书后面讲解访问堆栈存储器数据的指令时再进行说明。这个寄存器作为16位寄存器被引用时，为SP；如果作为32位寄存器，则是ESP。
>
>**RFLAGS** 用于指示微处理器的状态并控制它的操作。图2-2展示了所有型号微处理器的标志寄存器。注意，从8086/8088直到Core2微处理器是向上兼容的。8086/80286包含FLAG寄存器（16位），80386及更高型号的微处理器包含EFLAG寄存器（32位扩展的标志寄存器）。64位RFLAGS包含EFLAG寄存器，这在64位版本中也是不变的。

![Fixgure 1 "Intel未处理的FLAGS寄存器"][5]

上图最右边的5位标志和溢出标志在执行算术和逻辑指令后会改变，而对于任何数据传送或程序控制操作这些标志都不改变。某些标志也用于控制微处理器中的一些特性功能。下面列出每个标志位及其功能的简要说明。后续章节里介绍指令时，再给出关于标志位的更详细的叙述。

>**CF（进位）** 进位标志保存加法以后的进位或减法以后的借位。也可用进位标志指示由某些程序或过程引发的错误条件，这对DOS功能调用尤其有用。
>
>**PF（奇偶校验）** 奇偶校验标志表示结果数中1的个数是奇数还是偶数，是奇数则标志是逻辑0，是偶数则该标志是逻辑1。如果某个二进制数含有3个为1的位，它的奇偶性为奇数。如果某个二进制数包含0个为1的位，它的奇偶性为偶数。奇偶校验标志在现代程序设计中很少使用，它是早期Intel微处理器在数据通信环境中校验数据的一种手段。今天，奇偶校验常常由数据通信设备完成，而不是由微处理器完成。
>
>**AF（辅助进位）** 辅助进位标志保存加法后结果中的第3位与第4位之间的进位（半进位），或者减法后结果中的第3与第4位之间的借位。DAA和DAS指令测试这个特殊标志位，以便在BCD加法或减法后对AL中的值进行十进制调整。除此以外，微处理器或者任何其他指令都不使用A标志位。
>
>**ZF（零）** 零标志表示一个算术或逻辑操作的结果是否为零。如果Z=1，表示结果为0；如果Z=0，说明结果不为0。这可能令人迷惑，但Intel就是这样命名这个标志的。
>
>**SF（符号）** 符号标志保持执行算术或逻辑运算指令后所得结果的算术符号。如果S=1，则符号位（数的最左一位）为1或为负；如果S=0，则符号位为0或为正。
>
>**TF（陷阱）** 陷阱标志使能微处理器芯片上的调试功能（对程序进行调试，以便找到错误或故障）。如果T标志为使能（为1），则微处理器根据调试寄存器和控制寄存器的指示中断程序流；如果T标志为逻辑0，则禁止陷阱（调试）性能。Visual C++调试工具可以利用陷阱特性和调试寄存器调试有缺陷的软件。
>
>**IF（中断）** 中断标志控制INTR（中断请求）输入引脚的操作。如果I=1，则使能INTR引脚；如果I=0，则禁止INTR引脚。I标志的状态由STI（置位I标志）和CLI（清除I标志）指令控制。
>
>**DF（方向）** 在串指令操作期间，方向标志为DI和/或SI寄存器选择递增方式或递减方式。如果D=1，则寄存器内容自动地递减；如果D=0，则寄存器内容自动地递增。D标志用STD（置位方向）指令置位，用CLD（清除方向）指令清除。
>
>**OF（溢出）** 溢出标志在有符号数进行加或减时可能出现。溢出指示运算结果已超出机器能够表示的范围。例如，用8位加法将7FH（+127）加上01H（-1），结果为80H（-128）。这个有符号数加法结果的溢出状况由溢出位指示。对于无符号数的操作，不考虑溢出标志。


## IOPL（I/O优先级）

输入/输出优先级标志用于在保护模式下操作时为I/O设备选择优先级。如果当前任务的优先级高于或等于IOPL，则I/O指令能顺利执行。如果当前优先级比IOPL低，则产生中断，导致执行程序被挂起。注意，00级是最高（最大）优先级，11是最低（最小）优先级。

>**NT（任务嵌套）** 任务嵌套标志指示在保护模式下当前执行的任务嵌套于另一任务中。当任务被软件嵌套时，这个标志置位。
>
>**RF（恢复）** 恢复标志在调试时使用，控制在下条指令后恢复程序的执行。
>
>**VM（虚拟模式）** 虚拟模式标志位用于在保护模式系统中选择虚拟操作模式。虚拟模式系统允许多个1MB长的DOS存储器分区共存于存储系统中。这样可以允许系统执行多个DOS程序。VM用于在现代Windows环境下仿真DOS。
>
>**AC（对齐检查）** 当寻址一个字或双字时，如果地址不是在字或双字的边界上，对齐检查标志位就被激活为1。只有80486SX微处理器包含对齐检查位，这个位用来与其配套的协处理器80487SX同步。
>
>**VIF（虚拟中断）** 虚拟中断标志是中断标志位的副本，只有Pentium 4微处理器才有。
>**VIP（虚拟中断挂起）** 虚拟中断挂起标志为Pentium 4微处理器提供有关虚拟模式中断的信息。它用于多任务环境下，为操作系统提供虚拟中断标志和中断挂起信息。
>
>**ID（标识）** 标识标志指示PentiumPentium 4微处理器支持CPUID指令。CPUID指令给系统提供有关Pentium微处理器的信息，如版本号和制造商。

### 段寄存器

另外的一些寄存器叫做段寄存器，用来和微处理器中的其他寄存器结合生成存储器地址。不同型号的微处理器中有4个或者6个段寄存器。段寄存器的功能在实模式下和保护模式下是不同的。本章后面对段寄存器在实模式下和在保护模式下的功能进行详细说明。在64位平展模式操作中，段寄存器除了代码段寄存器外很少在程序中使用。下面先列出各个段寄存器及其在系统中的功能：

>**CS（代码段）** 代码段是一个存储器区域，在这里保存微处理器使用的代码（程序和过程）。代码段寄存器定义了存放代码的存储器段的起始地址。在实模式下工作时，它定义一个64KB存储器段的起始地址；在保护模式下工作时，它选择一个描述代码存储器起始地址和长度的描述符。对于808680286，代码段限制为64KB；80386及更高型号的微处理器工作在保护模式下时，代码段限制为4GB。在64位模式中，代码段寄存器仍然应用于平展模式，但是它的用法与2.5小节介绍的其他可编程模式不同。
>
>**DS（数据段）** 数据段也是一段存储区域，含有程序使用的大部分数据。可以通过偏移地址或者其他含有偏移地址的寄存器的内容访问数据段里的数据。和代码段及其他段一样；对于808680286，数据段的长度限制为64KB；对于80386及更高型号的微处理器，数据段的长度限制为4GB。
>
>**ES（附加段）** 附加段是一个附加的数据段，为某些串指令存放目的数据。
>
>**SS（堆栈段）** 堆栈段为堆栈定义一个存储区域。由堆栈段和堆栈指针寄存器确定堆栈段内当前的入口地址。BP寄存器也可以寻址堆栈段内的数据。
>
>FS和GSFS和GS段是在80386Core2微处理器中增加的段寄存器，以便允许程序访问这两个附加的存储器段。Windows将这些段寄存器用于内部操作，但没有说明其使用方法。

# 相关资料

* [《Intel微处理器》][1]
* [标志寄存器FLAGS----小总结][3]
* [Intel 80X86寄存器分类介绍][4]


[1]:    http://www.amazon.cn/Intel%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8-%E5%B8%83%E9%9B%B7/dp/B003U2RZ6C
[3]:    http://blog.csdn.net/u010481185/article/details/8949844
[4]:    http://blog.chinaunix.net/uid-10014667-id-471549.html
[5]:    /image/the_intel_microprocessors_note_1_fig_1.png

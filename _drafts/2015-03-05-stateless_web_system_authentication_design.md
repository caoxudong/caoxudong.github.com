---
title:      网站应用中无状态系统身份认证设计
layout:     post
category:   blog
tags:       [web, authentication, cookie, security]
---

# 无状态

[HTTP协议][3]本身是[无状态的][2]、响应式的，而应用规范（如[servlet规范][1]）则在其中添加了会话跟踪机制（如session）来保存用户状态。

网站规模不断增大，使用负载均衡在所难免，而这给后端服务器保存用户状态带来了不小的麻烦。一般来说，后端服务器在保存session时，会有3种方案：

1. 粘滞session： 通过某些规则，将某个用户的所有请求都固定到某台服务器，这样，用户的session信息就只会存在于其对应的某台服务器上。
2. session复制： 将应用服务器连接起来，若某个用户修改器session信息，则目标服务器会改session广播到所有的应用服务器中，做同步修改。这样，任何一台应用服务器就都可以处理用户请求了。
3. session共享： 设置一个第三方的session服务器（集群）来存储用户session信息，应用服务器自身不再存储session信息。每次使用session信息时，都是从session服务器来存取的。

上面的3种方案，都可以在实现在负载均衡环境下使用session，但却都有一些问题，不利于整个系统的水平扩展，可用性也不甚理想：

1. 方案1中，若是目标服务器宕机，则会造成用户无法访问。此时，若将该用户的请求路由到其他服务器，而其他服务器上并没有该用户的session信息，导致用户重新登陆。而当原服务器恢复后，若是将用户再定向到原服务器，则用户还得登陆一次，若不重定向用户请求，则可能会造成各个服务器之前忙闲不均。
2. 方案2中，随着用户量和服务器数量不断增长，各个服务器之间传递session数据所带来的网络消耗也不断增长，增加系统延时。
3. 方案3中，若是使用单一的第三方服务器，则会产生单点问题，若是使用集群，则又需要花费力气去维护集群。

考虑到上面的方案及其缺陷，越来越多的系统采用了无状态设计，即不在后端服务器中维护用户状态，用户的各个请求之间不再有相互依赖，并且在每个请求中都包含完整的验证信息，后端服务器在接收到请求后，再对用户身份进行验证，若验证通过则可以执行请求。使用无状态设计，后端服务器的角色完全一致，具有较高的扩展性，直接添加新的服务器就行。

# 身份验证

## 有状态系统的身份验证

普通情况下的身份验证是，用户提供用户名和密码，后端服务器进行验证，若成功，则会在该用户的session中记录相关信息，例如将当前登陆用户的对象信息记录在session，以便完成该用户后续的请求。

由于用户后续的请求需要依赖于这个登陆操作，因此说这个是有状态的。正如前面所说，有状态的系统在扩展性和可用性上有些问题，因此要修改为无状态的。

## 无状态系统的身份验证

无状态系统中，需要对用户的每个请求做身份验证。让用户在每个请求前都输一遍用户名密码肯定是不行的，用户会骂娘的，因此需要在客户端记录一些身份验证信息，用户提交请求时，将这些身份验证信息提交到服务器，完成身份验证。

[cookie][5]可以完成客户端存储的功能（其实也不好，后面再说），可以在其中存储身份验证信息，当用户提交请求时，这些信息会随请求一起发送给服务器，从而完成身份验证，当然，不能在cookie中直接存储用户的明文密码，实在太凶残。换个思路，在用户通过用户名密码登录后，由应用服务器为用户生成一个"密码"，并"发回"给用户，那么下一次用户就可以使用用户名和这个临时"密码"来访问网站的。

具体来说，就是在用户登录后，应用服务器根据用户信息生成一个auth_token，将之以cookie的形式"发回"给用户。用户再次发送请求时，会将这个auth_token带回给服务器。服务器通过userId查找到用户信息，再对比auth_token是否相同，来判断用户身份是否认证通过。之所以这里没有直接使用(userId+auth_token)组合来查找用户信息，为了安全方面的考虑，后文会介绍到。



# 安全

## 



# resources

1. [HTTP][3]
2. [stateless protocol][2]
3. [Representational state transfer][4]
4. [serlvet3 specification][1]
5. [Hacking Github with Webkit][6]






[1]:    https://jcp.org/en/jsr/detail?id=315
[2]:    http://en.wikipedia.org/wiki/Stateless_protocol
[3]:    https://www.ietf.org/rfc/rfc2616.txt
[4]:    http://en.wikipedia.org/wiki/Representational_state_transfer
[5]:    http://en.wikipedia.org/wiki/HTTP_cookie
[6]:    http://homakov.blogspot.com/2013/03/hacking-github-with-webkit.html
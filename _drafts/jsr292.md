---
title:      JSR 292
layout:     post
category:   blog
tags:       [java, jvm, jsr, lambda]
---

>以下内容基于JDK8

# what

随着JVM平台不断发展，有一些动态类型语言都有了JVM平台的实现。但之前JVM平台的设计都是按照静态类型语言来搞的，而动态类型语言并没有这些静态信息，因此编译在生成JVM指令时颇为不便。此外，当时的JVM并不能很好支持动态修改已有的类和方法，而这个功能对于一些动态类型语言来说却很常用。

以上就是[JSR 292][2]要解决的问题，解决方式就是在修改JVM规范，添加`invokedynamic`指令。

在JSR 292之前，函数调用的指令共有4个，分别是`invokestatic`，`invokespecial`，`invokeinterface`和`invokevirtual`，他们的任务大致如下：

1. 校验目标函数的对象类型是否匹配，`invokestatic`不做这一步
2. 校验目标函数的参数类型是否匹配
3. 在Java类中查找目标方法
4. 缓存查找到的方法
5. 调用方法

咱们自己写代码时，调用函数实际上可以分为几个步骤：

1. 定义函数
2. 定位调用函数的位置
3. 准备函数参数
4. 确定要调用的函数
5. 调用函数

以往的`invoke*`系列指令是针对静态类型语言设计的，定义函数时会提供足够的类型信息，因此能够把 **确定要调用的函数**和 **调用函数**这两件事打包一起干了；而在动态类型语言中，函数的定义往往没有足够的类型信息，无法在JVM准确找到目标方法，需要开发者自己实现一套调用逻辑。以JRuby为例，函数调用的执行过程大致是这样的：

    public abstract class CachingCallSite extends CallSite {
        protected CacheEntry cache = CacheEntry.NULL_CACHE;
        private final String methodName = ...
        public IRubyObject call(...) {
            RubyClass selfType = getClass(self);
            CacheEntry cache = this.cache;
            if (CacheEntry.typeOk(cache, selfType)) {
                return cache.method.call(...);
            }
            return cacheAndCall(...);
        } 
        
        protected IRubyObject cacheAndCall(...) {
            CacheEntry entry = selfType.searchWithCache(methodName);
            DynamicMethod method = entry.method;
            if (methodMissing(method, caller)) {
                return callMethodMissing(context, self, method);
            }
            updateCache(entry);
            return method.call(context. self, selfType, methodName);
        }
    }

这里面，需要指定函数查找策略，例如`selfType.searchWithCache(methodName)`，然后再执行函数调用`method.call(context. self, selfType, methodName)`。
每次函数调用时，都需要做这一坨事情，效率自然不行，而且隔着这么一坨代码，也无法对JRuby的代码应用JIT优化。

在JSR 292之后，通过[`invokedynamic`][5]指令，开发者可以通过 **bootstrap方法**设置`CallSite`，之后再执行的时候，JVM会替换掉`invokedynamic`指令，执行`CallSite`中的目标方法，避免每次都调用一坨过渡代码，使JVM可以对JRuby的代码进行优化。







将绑定操作放到JVM中完成，一方面，精简了JRuby编译的所生成的代码，另一方面，绑定后可以实现类似于直接调用底层方法实现的效果，JVM可以对绑定后的代码应用JIT优化，提升执行效率。例如下面的ruby代码:

`addtwo`方法的参数没有类型信息，因此在编译的时候无法确定`+`到底应该调用何种方法实现。有了`invokedynamic`指令后，编译器在这里只是生成一个 **invokedynamic call site**，然后提供相应的方法实现，通过






>Each occurrence of an invokedynamic instruction is called a dynamic call site.

字节码中，每个出现`invokedynamic`指令的地方，都是一个 **动态调用点(dynamic call site)**

>A method handle is a typed, directly executable reference to an underlying method, constructor, field, or similar low-level operation, with optional transformations of arguments or return values. These transformations are quite general, and include such patterns as conversion, insertion, deletion, and substitution.
>
>Method handles are dynamically and strongly typed according to their parameter and return types. They are not distinguished by the name or the defining class of their underlying methods. A method handle must be invoked using a symbolic type descriptor which matches the method handle's own type descriptor.

[API文档][1]对`MethodHandle`的定义是，一个 **动态的**，**强类型的**，**可直接执行的**，**对底层方法实现**的 **引用**。`MethodHandle`之间不以方法的名字或声明方法的类来区别，而是以方法的`MethodType`（包括参数类型和返回值类型）来区别。

其中：

* **动态的**: 类型检查发生在首次调用时
* **强类型的**: 不支持自动类型转换
* **可直接执行的**: 通过`MethodHandle#invoke`方法族来调用底层方法
* **对底层方法实现**: `MethodHandle`本身并不包含具体的方法实现
* **引用**: 顾名思义，是个引用。

使用的时候，需要先通过方法签名(形参和返回值的类型，不包括函数名)找到`MethodHandle`，然后通过`invokeExact`或`invoke`方法调用，调用的时候需要传入实参和调用接收者。示例如下：

    public class MethodHandleDemo {

        public static void main(String[] args) throws Throwable {
            Lookup lookup = MethodHandles.lookup();
            MethodHandle plusMethodHandle =
                    lookup.findStatic(MethodHandleDemo.class, "plus",
                            MethodType.methodType(int.class, new Class[] {
                                    int.class, int.class }));
            MethodHandle subtractMethodHandle =
                    lookup.findVirtual(MethodHandleDemo.class, "subtract",
                            MethodType.methodType(BigDecimal.class, new Class[] {
                                    BigDecimal.class, BigDecimal.class }));

            MethodHandleDemo demo = new MethodHandleDemo();
            int plusResult = (int) plusMethodHandle.invokeExact(1, 2);
            System.out.println("call plus method handle: " + plusResult);
            BigDecimal subtractResult = (BigDecimal) subtractMethodHandle
                    .invokeExact(demo, new BigDecimal(3), new BigDecimal(4));
            System.out.println("call subtract method handle: " + subtractResult);
        }

        private static int plus(int a, int b) {
            return a + b;
        }

        private BigDecimal subtract(BigDecimal a, BigDecimal b) {
            return a.subtract(b);
        }

    }

这种使用方式使开发者可以将函数声明和具体实现分开，然后在运行时执行绑定。

# why




# how

# method handle

* currying



# Resources

* [API Reference][1]
* [JSR 292 Cookbook][2]
* [JSR 292][3]
* [JRuby and Invokedynamic][4]
* [Bytecode invokedynamic][5]
* [Support for Non-Java Languages][6]
* [New JDK 7 Feature: Support for Dynamically Typed Languages in the Java Virtual Machine][7]
* [Invokedynamic in JRuby: Constant Lookup][8]




[1]:    https://docs.oracle.com/javase/8/docs/api/java/lang/invoke/MethodHandle.html
[2]:    http://cr.openjdk.java.net/~jrose/pres/200906-Cookbook.htm
[3]:    https://jcp.org/en/jsr/detail?id=292
[4]:    https://www.slideshare.net/CharlesNutter/jruby-and-invokedynamic-japan-jug-2015
[5]:    https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.invokedynamic
[6]:    https://docs.oracle.com/en/java/javase/13/vm/support-non-java-languages.html#GUID-99173E26-45BC-40F9-976B-C19D67D1DB74
[7]:    https://www.oracle.com/technical-resources/articles/javase/dyntypelang.html
[8]:    http://blog.headius.com/2011/08/invokedynamic-in-jruby-constant-lookup.html
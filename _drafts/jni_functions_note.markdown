---
title:      JNI开发
layout:     post
category:   blog
tags:       [java, jni, jvm]
---

# chap1 简介

没啥可说的

# chap2 设计概览

## 2.1 JNI函数和指针

本地代码通过可以通过一系列JNI函数来访问JVM的内部数据，而想要访问这一系列JNI函数，又需要通过一个JNI接口指针(JNI Interface Pointer)才行，如下图所示

                                                Array of pointers       +---------------------+
                                                to JNI functions    +-> |an interface function|
    +-------------+     +---------------+      +-----------------+  |   +---------------------+
    |JNI interface+---> |Pointer        +--+-> |Pointer          +--+
    |pointer      |     +---------------+  |   +-----------------+      +---------------------+
    |             |     |per-thread JNI |  +-> |Pointer          +----> |an interface function|
    +-------------+     |data structure |  |   +-----------------+      +---------------------+
                        +---------------+  +-> |Pointer          +--+
                                               +-----------------+  |   +---------------------+
                                               |...              |  +-> |an interface function|
                                               +-----------------+      +---------------------+

JNI接口指针的设计有些类似于C++的虚函数表，这样做的好处是，可以通过JNI命名空间来隔离本地代码，JVM可以借此提供多个版本的JNI函数表，例如一个版本用来做调试，效率不高，但会做更多的参数检查，另一个版本用于做正式使用，参数检查较少，但效率更高。

JNI函数接口只能在当前线程使用，**禁止**将接口指针传给其他线程，当在同一个线程中多次调用本地方法时，JVM保证传递的是相同的接口指针。由于本地方法可能被不同的Java线程调用，因此可能传入不同的接口指针。

## 2.2 编译、载入、链接本地方法

JVM本身是支持多线程的，因此在编译、链接本地代码库的时候，也要添加多线程的支持。例如，在使用Sun Studio编译器编译代码时，应该添加`-mt`标记，使用GCC编译代码时，应该使用`-D_REENTRANT`或`-D_POSIX_C_SOURCE`标记。编译本地代码库之后，可以通过`System.loadLibrary`方法来载入本地库，如下所示：

    ```java
    package pkg; 

    class Cls {
        native double f(int i, String s);
        static {
            System.loadLibrary("pkg_Cls");
        }
    }
    ```

编译后的本地代码库要符合目标操作系统的命名约定，例如在Solaris系统上，`pkg_Cls`代码库的名字应该是`libpkg_Cls.so`，在Windows系统上，`pkg_Cls`代码库的名字应该是`pkg_Cls.dll`。

上面说的动态库，JVM也可以使用静态库，但这需要与JVM的实现绑定在一起，`System.loadLibrary`或其他等价的方法在加载静态库的时候，必须成功。

当且仅当静态库对外导出了名为`JNI_OnLoad_L`的函数时，并且与JVM绑定在一起时，才是真正的静态链接。如果静态库中既包含函数`JNI_OnLoad_L`，又包含函数`JNI_OnLoad`，则函数`JNI_OnLoad`会被忽略。如果某个代码库`L`是静态链接的，则当首次调用`System.loadLibrary`或其他等价方法时，会执行`JNI_OnLoad_L`方法，其参数和返回值与`JNI_OnLoad`方法相同。

若某个静态库的名字是`L`，则无法在加载具有相同名字的动态库。

当包含了某个静态库的类加载器被GC掉，并且该静态库中导出了名为`JNI_OnUnload_L`函数时，会调用`JNI_OnUnload_L`完成清理工作。类似的，若静态库中同时导出了名为`JNI_OnUnLoad_L`和`JNI_OnUnLoad`的函数，则函数`JNI_OnUnLoad`会被忽略掉。

开发者可以调用JNI函数`RegisterNatives`来注册某个类的本地方法，这对静态链接的函数非常有用。

## 2.2 解析本地方法名

动态链接器会根据本地方法的方法名来解析函数入口，方法名遵循如下规则：

* 函数名带有`Java_`前缀
* 后跟以下划线完整类名，类的包名分隔符`.`以`_`来代替
* 后跟函数名
* 对于重载的本地方法，会使用双下划线(`__`)来分隔参数签名

JVM根据本地方法名查找方法的规则如下：

* 先查找不带参数签名的方法
* 再查找带参数签名的方法

这里值得注意的是，如果本地方法和非本地方法同名，其实并不需要使用带参数签名的方法名，因为非本地方法不会存在于本地代码库中。

由于Java代码中支持Unicode字符，因此为了与C语言兼容，需要对本地方法中的非ASCII字符进行转义，规则如下：

* 使用`_0XXXX`表示非ASCII的Unicode字符，注意这里使用的小写字符，例如`_0abcd`
* 使用`_1`表示下划线`_`
* 使用`_2`表示分号`;`
* 使用`_3`表示中括号`[`

代码示例：

    ```java
    public class Hello {
        private native int sum(int a, int b);
        private native String concat(String a, String b);
        private native String 试试(String a, String b);

        public static void main(String[] args) {
            System.out.println(new Hello().sum(1,2));
            System.out.println(new Hello().concat("caoxudong is ", "testging"));
        }

        static {
            System.loadLibrary("Hello");
        }

    }
    ```

使用`javah`编译后的头文件

    ```c
    /* DO NOT EDIT THIS FILE - it is machine generated */
    #include <jni.h>
    /* Header for class Hello */

    #ifndef _Included_Hello
    #define _Included_Hello
    #ifdef __cplusplus
    extern "C" {
    #endif
    /*
    * Class:     Hello
    * Method:    sum
    * Signature: (II)I
    */
    JNIEXPORT jint JNICALL Java_Hello_sum
    (JNIEnv *, jobject, jint, jint);

    /*
    * Class:     Hello
    * Method:    concat
    * Signature: (Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;
    */
    JNIEXPORT jstring JNICALL Java_Hello_concat
    (JNIEnv *, jobject, jstring, jstring);

    /*
    * Class:     Hello
    * Method:    _08bd5_08bd5
    * Signature: (Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;
    */
    JNIEXPORT jstring JNICALL Java_Hello__08bd5_08bd5
    (JNIEnv *, jobject, jstring, jstring);

    #ifdef __cplusplus
    }
    #endif
    #endif
    ```

## 本地方法参数

* 第一个参数是JNI接口指针，`JNIEnv *`
* 第二个参数是Java对象，具体值取决于当前方法是静态方法还是实例方法，若是静态方法，则表示类对象，若是实例方法，则表示实例对象
* 其余参数与定义本地方法时的参数一一对应

**需要注意的是，一定要使用JNI接口指针来操作Java对象，不要耍小聪明绕过JNI接口指针。**

## 引用Java对象

像整型(`int`)和字符(`char`)原生类型的数据会在Java代码和本地代码之间互相拷贝数据，而其他引用类型的对象则可以在Java代码和本地代码之间传递引用。JVM需要跟踪所有传递给本地代码的对象，防止其被垃圾回收；另一方面，本地代码需要有一种途径来告知JVM哪些对象可以被回收掉；此外，垃圾回收器需要能够移动本地代码所引用的对象。

## 全局引用和局部引用

JNI将本地代码所使用的对象分为全局引用(`global reference`)和本地引用(`local reference`)。本地引用只在本地方法调用中有效，当本地方法退出时，会自动释放掉；而全局引用在显式调用释放方法前，会一直有效。

一些操作原则：

* 对象是作为局部引用传递给本地方法的
* JNI函数返回的Java对象也都是局部引用的
* 开发者可以使用局部引用来创建全局引用
* 意图接收Java对象的JNI函数，即可以接收局部引用，也可以接收全局引用
* 本地方法返回给JVM的结果，即可以是局部引用，也可以是全局引用





# Resources

* [Java Native Interface Specification Contents][1]



[1]:    http://docs.oracle.com/javase/8/docs/technotes/guides/jni/spec/jniTOC.html
---
title:      JNI开发
layout:     post
category:   blog
tags:       [java, jni, jvm]
---

# 目录

* [1 简介][2]
* [2 设计概览][3]
    * [2.1 JNI函数和指针][4]
    * [2.2 编译、载入、链接本地方法][5]
        * [2.2.1 解析本地方法名][6]
        * [2.2.2 本地方法参数][7]
    * [2.3 引用Java对象][8]
        * [2.3.1 全局引用和局部引用][9]
        * [2.3.2 实现局部引用][10]
    * [2.4 访问Java对象][11]
        * [2.4.1 访问原生类型的数组][12]
        * [2.4.2 访问属性和方法][13]
        * [2.4.3 报告程序错误][14]
    * [2.5 Java异常][15]
        * [2.5.1 异常和错误码][16]
        * [2.5.2 异步异常][17]
        * [2.5.3 异常处理][18]
* [3 JNI的类型和数据结构][19]
    * [3.1 原生类型][20]
    * [3.2 引用类型][21]
    * [3.3 属性和方法ID][22]
    * [3.4 值类型][23]
    * [3.5 类型签名][24]
    * [3.6 UTF-8字符串][25]

<a name="1"></a>
# 1 简介

没啥可说的

<a name="2"></a>
# 2 设计概览

<a name="2.1"></a>
## 2.1 JNI函数和指针

本地代码通过可以通过一系列JNI函数来访问JVM的内部数据，而想要访问这一系列JNI函数，又需要通过一个JNI接口指针(JNI Interface Pointer)才行，如下图所示

                                                Array of pointers       +---------------------+
                                                to JNI functions    +-> |an interface function|
    +-------------+     +---------------+      +-----------------+  |   +---------------------+
    |JNI interface+---> |Pointer        +--+-> |Pointer          +--+
    |pointer      |     +---------------+  |   +-----------------+      +---------------------+
    |             |     |per-thread JNI |  +-> |Pointer          +----> |an interface function|
    +-------------+     |data structure |  |   +-----------------+      +---------------------+
                        +---------------+  +-> |Pointer          +--+
                                               +-----------------+  |   +---------------------+
                                               |...              |  +-> |an interface function|
                                               +-----------------+      +---------------------+

JNI接口指针的设计有些类似于C++的虚函数表，这样做的好处是，可以通过JNI命名空间来隔离本地代码，JVM可以借此提供多个版本的JNI函数表，例如一个版本用来做调试，效率不高，但会做更多的参数检查，另一个版本用于做正式使用，参数检查较少，但效率更高。

JNI函数接口只能在当前线程使用，**禁止**将接口指针传给其他线程，当在同一个线程中多次调用本地方法时，JVM保证传递的是相同的接口指针。由于本地方法可能被不同的Java线程调用，因此可能传入不同的接口指针。

<a name="2.2"></a>
## 2.2 编译、载入、链接本地方法

JVM本身是支持多线程的，因此在编译、链接本地代码库的时候，也要添加多线程的支持。例如，在使用Sun Studio编译器编译代码时，应该添加`-mt`标记，使用GCC编译代码时，应该使用`-D_REENTRANT`或`-D_POSIX_C_SOURCE`标记。编译本地代码库之后，可以通过`System.loadLibrary`方法来载入本地库，如下所示：

    ```java
    package pkg; 

    class Cls {
        native double f(int i, String s);
        static {
            System.loadLibrary("pkg_Cls");
        }
    }
    ```

编译后的本地代码库要符合目标操作系统的命名约定，例如在Solaris系统上，`pkg_Cls`代码库的名字应该是`libpkg_Cls.so`，在Windows系统上，`pkg_Cls`代码库的名字应该是`pkg_Cls.dll`。

上面说的动态库，JVM也可以使用静态库，但这需要与JVM的实现绑定在一起，`System.loadLibrary`或其他等价的方法在加载静态库的时候，必须成功。

当且仅当静态库对外导出了名为`JNI_OnLoad_L`的函数时，并且与JVM绑定在一起时，才是真正的静态链接。如果静态库中既包含函数`JNI_OnLoad_L`，又包含函数`JNI_OnLoad`，则函数`JNI_OnLoad`会被忽略。如果某个代码库`L`是静态链接的，则当首次调用`System.loadLibrary`或其他等价方法时，会执行`JNI_OnLoad_L`方法，其参数和返回值与`JNI_OnLoad`方法相同。

若某个静态库的名字是`L`，则无法在加载具有相同名字的动态库。

当包含了某个静态库的类加载器被GC掉，并且该静态库中导出了名为`JNI_OnUnload_L`函数时，会调用`JNI_OnUnload_L`完成清理工作。类似的，若静态库中同时导出了名为`JNI_OnUnLoad_L`和`JNI_OnUnLoad`的函数，则函数`JNI_OnUnLoad`会被忽略掉。

开发者可以调用JNI函数`RegisterNatives`来注册某个类的本地方法，这对静态链接的函数非常有用。

<a name="2.2.1"></a>
### 2.2.1 解析本地方法名

动态链接器会根据本地方法的方法名来解析函数入口，方法名遵循如下规则：

* 函数名带有`Java_`前缀
* 后跟以下划线完整类名，类的包名分隔符`.`以`_`来代替
* 后跟函数名
* 对于重载的本地方法，会使用双下划线(`__`)来分隔参数签名

JVM根据本地方法名查找方法的规则如下：

* 先查找不带参数签名的方法
* 再查找带参数签名的方法

这里值得注意的是，如果本地方法和非本地方法同名，其实并不需要使用带参数签名的方法名，因为非本地方法不会存在于本地代码库中。

由于Java代码中支持Unicode字符，因此为了与C语言兼容，需要对本地方法中的非ASCII字符进行转义，规则如下：

* 使用`_0XXXX`表示非ASCII的Unicode字符，注意这里使用的小写字符，例如`_0abcd`
* 使用`_1`表示下划线`_`
* 使用`_2`表示分号`;`
* 使用`_3`表示中括号`[`

代码示例：

    ```java
    public class Hello {
        private native int sum(int a, int b);
        private native String concat(String a, String b);
        private native String 试试(String a, String b);

        public static void main(String[] args) {
            System.out.println(new Hello().sum(1,2));
            System.out.println(new Hello().concat("caoxudong is ", "testging"));
        }

        static {
            System.loadLibrary("Hello");
        }

    }
    ```

使用`javah`编译后的头文件

    ```c
    /* DO NOT EDIT THIS FILE - it is machine generated */
    #include <jni.h>
    /* Header for class Hello */

    #ifndef _Included_Hello
    #define _Included_Hello
    #ifdef __cplusplus
    extern "C" {
    #endif
    /*
    * Class:     Hello
    * Method:    sum
    * Signature: (II)I
    */
    JNIEXPORT jint JNICALL Java_Hello_sum
    (JNIEnv *, jobject, jint, jint);

    /*
    * Class:     Hello
    * Method:    concat
    * Signature: (Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;
    */
    JNIEXPORT jstring JNICALL Java_Hello_concat
    (JNIEnv *, jobject, jstring, jstring);

    /*
    * Class:     Hello
    * Method:    _08bd5_08bd5
    * Signature: (Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;
    */
    JNIEXPORT jstring JNICALL Java_Hello__08bd5_08bd5
    (JNIEnv *, jobject, jstring, jstring);

    #ifdef __cplusplus
    }
    #endif
    #endif
    ```

<a name="2.2.2"></a>
### 2.2.2 本地方法参数

* 第一个参数是JNI接口指针，`JNIEnv *`
* 第二个参数是Java对象，具体值取决于当前方法是静态方法还是实例方法，若是静态方法，则表示类对象，若是实例方法，则表示实例对象
* 其余参数与定义本地方法时的参数一一对应

**需要注意的是，一定要使用JNI接口指针来操作Java对象，不要耍小聪明绕过JNI接口指针。**

<a name="2.3"></a>
## 2.3 引用Java对象

像整型(`int`)和字符(`char`)原生类型的数据会在Java代码和本地代码之间互相拷贝数据，而其他引用类型的对象则可以在Java代码和本地代码之间传递引用。JVM需要跟踪所有传递给本地代码的对象，防止其被垃圾回收；另一方面，本地代码需要有一种途径来告知JVM哪些对象可以被回收掉；此外，垃圾回收器需要能够移动本地代码所引用的对象。

<a name="2.3.1"></a>
### 2.3.1 全局引用和局部引用

JNI将本地代码所使用的对象分为全局引用(`global reference`)和本地引用(`local reference`)。本地引用只在本地方法调用中有效，当本地方法退出时，会自动释放掉；而全局引用在显式调用释放方法前，会一直有效。

一些操作原则：

* 对象是作为局部引用传递给本地方法的
* JNI函数返回的Java对象也都是局部引用的
* 开发者可以使用局部引用来创建全局引用
* 意图接收Java对象的JNI函数，即可以接收局部引用，也可以接收全局引用
* 本地方法返回给JVM的结果，即可以是局部引用，也可以是全局引用

大部分情况下，开发者可以不必关心局部引用的释放，JVM会做好这件事；在某些特殊场景下，才需要有开发者显式释放掉局部引用，例如：

* 本地方法访问了一个很大的Java对象，因此创建了一个指向该对象的局部引用，在返回到调用函数之前，该本地方法需要执行很多额外的工作，由于有局部引用指向该Java对象，即便该Java对象已经不再使用，它也不会被垃圾回收器回收掉
* JVM需要一块额外的内存空间来跟踪本地方法创建的局部引用，因此若本地方法创建了大量局部引用，则可能导致内存不足而引发错误，例如本地方法遍历某个很大的数据，访问其中的Java对象，每次迭代都会创建局部引用，而这个新创建的局部引用在本地迭代之后就不再使用，造成大量内存浪费

JNI允许开发者在本地方法中手动删除局部引用，而且除了将局部引用作为结果返回之外，JNI函数不可以创建额外的局部引用。

局部引用不是线程安全的，只可用在当前线程中。

<a name="2.3.2"></a>
### 2.3.2 实现局部引用

当从Java代码转换到本地代码时，JVM会创建注册表来记录不可移动的局部引用到Java对象的映射，同时避免该Java对象被垃圾回收器回收掉。调用本地方法时，传入传出的Java对象都会被添加到这个注册表中，当从本地方法返回时，该注册表会被删除，注册表中引用的对象也得以被垃圾回收器回收掉。

实现注册表有多种方法，例如哈希表、链表等。尽管使用引用计数可以避免在注册表中创建重复内容，但就JNI的具体实现来说，这并不是必要的。

需要注意的是，不能通过保守的遍历本地调用栈来实现局部引用，因为本地方法可能会将局部引用存储在全局或堆中的某个数据结构中。

<a name="2.4"></a>
## 2.4 访问Java对象

JNI通过局部引用和全局引用提供了一整套访问函数，使开发者可以不比关心JVM内部的具体实现，提升了JNI的适用性。

当然，通过访问函数来访问数据的开销肯定会比直接访问实际数据结构的开销大，但在大部分场景下，能逼得Java开发者通过本地方法来实现的功能，其执行开销本身就比调用访问函数的开销大得多，所以说，不必太过在意。

<a name="2.4.1"></a>
### 2.4.1 访问原生类型的数组

当然，在访问包含了大量原生数据类型数组时，若每次迭代都要调用JNI访问函数来访问数组元素，就太没有效率了。

一种解决方案是引入**pinning**机制，JVM锁定原始数组，并提供类似于游标的直接指针，以便本地代码可以访问数组元素，但这种方案有两个前提条件：

* 垃圾回收器能够支持**pinning**
* JVM必须将原生类型的数组放置在一个连续的内存空间上，大部分情况下也确实是这么实现的，不过在实现布尔类型的数组时可以将数组元素压缩存储，因此使用这种方式的代码不具备可移植性

这里，可以采用一种折衷的方法：

* 通过一系列函数来实现原生类型的数组在本地代码和Java代码之间的拷贝，当本地代码只需要访问数组中的少量数据时，使用这些拷贝函数即可；
* 若开发者确实需要访问大量的数组元素，还是通过另一系列类似直接指针的函数来访问数组元素，这时请一定牢记，这些函数可能需要JVM做一些内存分配或和数据拷贝的工作，实际执行时是否需要分配内存和拷贝数据取决于JVM的具体实现，例如：
    * 如果垃圾回收器支持**pinning**，而且数组对象的内存布局与本地代码的期望形式相同，则无需内存拷贝
    * 否则需要将数组拷贝到一块不可移动的内存区域(例如在C堆中分配内存)，执行一些必要的格式转换，再返回指向该内存块的指针
* 最后通过接口函数通知JVM，"本地代码无需再访问数组元素"，然后系统会释放对原始数组的锁定，接触原始数组和拷贝数组的关联关系，释放拷贝数组

这个方案有一些灵活性，垃圾回收器可以区别对待拷贝数组和原始数组，例如只拷贝小对象，而大对象则使用**pinning**机制来访问。

JNI的实现者必须保证，在多线程场景下运行的本地方法可以同时访问相同的数组对象，例如，JNI可能会使用引用技术来记录每个通过**pinning**机制来访问的数组对象，以便当所有访问该数组的线程退出本地方法时，可以退出**pinning**操作，但是JNI不能通过加锁来限制其他线程同时对数组进行访问。当然，同时访问数组元素，且没有进行同步控制时，访问结果是不确定的。

<a name="2.4.2"></a>
### 2.4.2 访问属性和方法

开发者可以通过JNI来访问Java对象的属性和方法。JNI可以通过属性和方法的符号名(symbolic names)和类型签名(type signatures)来定位具体的属性和方法。例如，要访问类`cls`中的方法`f`，可以使用如下方法：

    ```c++
    methodID mid = env->GetMethodID(cls, "f", "(ILjava/lang/String;)D");
    ```

在获取到方法之后，就可以重复使用了，无需每次都重新获取：

    ```c++
    jdouble result = env->CallDoubleMethod(obj, mid, 10, str);
    ```

这里需要注意的是，即便是获取到了方法或属性的ID，JVM也可能会卸载目标类，而卸载了目标类之后，ID也就无效了，因此，如果本地方法需要在一段时间内持续持有属性或方法ID，需要做一些额外的工作才能确保执行正确：

* 持有一个对目标类的引用
* 重新计算属性或方法的ID

JNI并不强制要求属性或方法ID该如如何实现。

<a name="2.4.3"></a>
### 2.4.3 报告程序错误

JNI并不检查像空指针或错误参数类型这样的程序错误，原因如下：

* 会降低本地方法的性能
* 很多时候，运行时类型信息不足，无法检查

大多数C语言程序库并不对程序错误加以预防，例如像`printf`这样的函数在遇到无效地址时，并不会报告错误代码，而是会引发一个运行时错误。因此，强制C语言程序库对所有可能错误进行检查没什么意义，用户代码本身就需要做检查，C语言运行库就无需再做一遍了。

开发者禁止将错误指针或参数传递给本地方法，否则可能会引发无法预知的结果，包括异常的系统状态或JVM崩溃。

<a name="2.5"></a>
## 2.5 Java异常

JNI允许本地代码抛出任何类型的异常，也可以处理被抛出的Java异常，若不处理，则会被返还给JVM继续处理。

<a name="2.5.1"></a>
### 2.5.1 异常和错误码

特定的JNI函数会使用Java的异常机制来报告异常，大部分情况下，JNI会通过返回错误码并抛出Java异常来报告错误。错误码通常是特定的返回值，例如`NULL`，因此开发者可以：

* 检查最后一次调用JNI函数的返回值来判断是否有错误发生
* 调用函数`ExceptionOccurred()`，获取包含了详细错误信息的异常对象

有两种情况，开发者需要检查异常对象，而不必检查JNI函数的返回值：

* JNI函数的返回值是通过调用Java方法而得到的。开发者必须调用`ExceptionOccurred()`方法来检查是否在Java方法中跑出了异常
* 某些JNI的数组访问函数没有返回值，但可能会抛出`ArrayIndexOutOfBoundsException`异常或`ArrayStoreException`异常

其他场景下，非错误的返回值保证了没有异常被抛出。

<a name="2.5.2"></a>
### 2.5.2 异步异常

在多线程场景下，非当前线程可能会抛出异步异常(asynchronous exception)，异步异常并不会立刻影响当前线程中本地代码的执行，直到满足以下条件之一：

* 本地代码调用了可能会抛出同步异常的JNI函数
* 本地代码调用`ExceptionOccurred()`方法来显式的检查是否有异常(同步或异步的)被抛出

注意，只有那些可能会抛出同步异常的JNI函数需要检查异步异常。

本地方法应该在适当的时机调用`ExceptionOccurred()`方法来确保当前线程可以在可控的时间范围内对异步异常进行相应。

<a name="2.5.3"></a>
### 2.5.3 异常处理

在本地代码中，有两种处理异常的方法：

* 本地代码可以立即返回，由本地方法的调用者来处理异常
* 本地方法可以调用`ExceptionClear()`方法清除异常信息，自己来处理异常

当有异常被抛出后，本地方法在调用其他JNI函数前，**必须**先清除异常信息。当有异常未被处理时，可以安全调用的JNI方法有：

* `ExceptionOccurred()`
* `ExceptionDescribe()`
* `ExceptionClear()`
* `ExceptionCheck()`
* `ReleaseStringChars()`
* `ReleaseStringUTFChars()`
* `ReleaseStringCritical()`
* `Release<Type>ArrayElements()`
* `ReleasePrimitiveArrayCritical()`
* `DeleteLocalRef()`
* `DeleteGlobalRef()`
* `DeleteWeakGlobalRef()`
* `MonitorExit()`
* `PushLocalFrame()`
* `PopLocalFrame()`

<a name="3"></a>
# 3 JNI的类型和数据结构

<a name="3.1"></a>
## 3.1 原生类型

原生类型和Java对象类型的对应关系如下：

    Java类型             原生类型             描述
    boolean             jboolean            unsigned 8 bits
    byte                jbyte               signed 8 bits
    char                jchar               unsigned 16 bits
    short               jshort              signed 16 bits
    int                 jint                signed 32 bits
    long                jlong               signed 64 bits
    float               jfloat              32 bits
    double              jdouble             64 bits
    void                void                not applicable

为了使用方便，在JNI中做了如下定义：

    ```c++
    #define JNI_FALSE  0
    #define JNI_TRUE   1
    ```

定义类型`jsize`来表示基本索引和大小：

    ```c++
    typedef jint jsize;
    ```

<a name="3.2"></a>
## 3.2 引用类型

JNI引入了一系列引用类型来对应Java中不同种类的对象，JNI中的引用类型有如下继承关系：

* `jobject`
    * `jclass`(`java.lang.Class`对象)
    * `jstring`(`java.lang.String`对象)
    * `jarray`(数组对象)
        * `jobjectArray`(对象数组)
        * `jbooleanArray`(布尔数组)
        * `jbyteArray`(字节数组)
        * `jcharArray`(字符数组)
        * `jshortArray`(短整型数组)
        * `jintArray`(整型数组)
        * `jlongArray`(长整型数组)
        * `jfloatArray`(浮点数数组)
        * `jdoubleArray`(双精度浮点数数组)
    * `jthrowable`(`java.lang.Throwable`对象)

在C语言中，所有其他的JNI引用类型都被定义为`jobject`，例如：

    ```c
    typedef jobject jclass;
    ```

而在C++语言中，JNI引入了一系列冗余类来维持继承体系，例如：

    ```c++
    class _jobject {};
    class _jclass : public _jobject {};
    // ...
    typedef _jobject *jobject;
    typedef _jclass *jclass;
    ```

<a name="3.3"></a>
## 3.3 属性和方法ID

在JNI中，属性和方法的ID被定义普通的指针：

    ```c
    struct _jfieldID;              /* opaque structure */
    typedef struct _jfieldID *jfieldID;   /* field IDs */

    struct _jmethodID;              /* opaque structure */
    typedef struct _jmethodID *jmethodID; /* method IDs */
    ```

<a name="3.4"></a>
## 3.4 值类型

值类型`jvalue`是一个联合体(`union type`)，用于表示参数数组，其定义如下：

    ```c
    typedef union jvalue {
        jboolean z;
        jbyte    b;
        jchar    c;
        jshort   s;
        jint     i;
        jlong    j;
        jfloat   f;
        jdouble  d;
        jobject  l;
    } jvalue;
    ```

<a name="3.5"></a>
## 3.5 类型签名

JNI沿用了JVM内部类型签名表示方法，如下所示：

    类型签名                         Java类型
    Z                               boolean
    B                               byte
    C                               char
    S                               short
    I                               int
    J                               long
    F                               float
    D                               double
    L full class name               full class name
    [ type                          type[]
    (arg-types)ret-type	            method type

例如，有如下Java方法：

    ```java
    long f (int n, String s, int[] arr);
    ```

其类型签名为：

    (ILjava/lang/String;[I)J

<a name="3.6"></a>
## 3.6 UTF-8字符串

JNI使用UTF-8编码来表示各种字符串类型，这与JVM所使用的编码相同。使用UTF-8编码，确保只包含非空的ASCII字符的字符串可以只用一个字节来存储一个字符，而且所有的Unicode字符都可以正确表示。

在` \u0001`到`\u007F`范围内的字符，可以只用一个字节表示，其中的低7位用来表示字符的编码值，例如：

* 0xxxxxxx

空白符和`\u0080`到`\u07FF`范围内的字符使用两个字节(x和y)来表示，字符的编码值使用公式`((x & 0x1f) << 6) + (y & 0x3f)`来计算，例如：

* x: 110xxxxx
* y: 10yyyyyy

范围在`'\u0800`到`\uFFFF'`的字符使用3个字节(x、y和z)来表示，字符的编码值使用公式`((x & 0xf) << 12) + ((y & 0x3f) << 6) + (z & 0x3f)`来计算，例如：

* x: 1110xxxx
* y: 10yyyyyy
* z: 10zzzzzz

范围在`U+FFFF`之上的字符(称之为**补充字符**)使用6个字节(u、v、w、x、y和z)来表示，字符的编码值使用公式` 0x10000+((v&0x0f)<<16)+((w&0x3f)<<10)+(y&0x0f)<<6)+(z&0x3f)`来计算。

对于那些需要使用多个字节来存储的字符来说，他们在class文件中是以大端序(big-endian)来存储的。

这种表示方式与b标准UTF-8格式有些区别：

* 空白符`0`使用两个字节来存储，因此JNI中的UTF-8字符串永远不会内嵌空白符
* JNI只使用了标准UTF-8格式中的1字节、2字节和3字节这3种格式，JVM无法识别4字节格式的标准UTF-8编码，而是使用2倍的3字节编码格式( two-times-three-byte format)






# Resources

* [Java Native Interface Specification Contents][1]



[1]:    http://docs.oracle.com/javase/8/docs/technotes/guides/jni/spec/jniTOC.html
[2]:    #1
[3]:    #2
[4]:    #2.1
[5]:    #2.2
[6]:    #2.2.1
[7]:    #2.2.2
[8]:    #2.3
[9]:    #2.3.1
[10]:   #2.3.2
[11]:   #2.4
[12]:   #2.4.1
[13]:   #2.4.2
[14]:   #2.4.3
[15]:   #2.5
[16]:   #2.5.1
[17]:   #2.5.2
[18]:   #2.5.3
[19]:   #3
[20]:   #3.1
[21]:   #3.2
[22]:   #3.3
[23]:   #3.4
[24]:   #3.5
[25]:   #3.6